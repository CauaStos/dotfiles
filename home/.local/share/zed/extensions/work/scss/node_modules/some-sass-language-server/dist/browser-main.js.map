{"version":3,"file":"browser-main.js","sources":["webpack://serverExportVar/../../node_modules/vscode-jsonrpc/lib/common/connection.js","webpack://serverExportVar/../../node_modules/vscode-jsonrpc/lib/common/messageBuffer.js","webpack://serverExportVar/../../node_modules/vscode-jsonrpc/lib/common/messageReader.js","webpack://serverExportVar/../language-services/dist/features/do-complete.js","webpack://serverExportVar/../language-services/dist/features/do-hover.js","webpack://serverExportVar/../language-services/dist/features/do-signature-help.js","webpack://serverExportVar/../language-services/dist/utils/sassdoc.js","webpack://serverExportVar/../vscode-css-languageservice/lib/esm/languageFacts/entry.js","webpack://serverExportVar/../vscode-css-languageservice/lib/esm/services/selectorPrinting.js"],"sourcesContent":["\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst messages_1 = require(\"./messages\");\nconst linkedMap_1 = require(\"./linkedMap\");\nconst events_1 = require(\"./events\");\nconst cancellation_1 = require(\"./cancellation\");\nvar CancelNotification;\n(function (CancelNotification) {\n    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\n})(CancelNotification || (CancelNotification = {}));\nvar ProgressToken;\n(function (ProgressToken) {\n    function is(value) {\n        return typeof value === 'string' || typeof value === 'number';\n    }\n    ProgressToken.is = is;\n})(ProgressToken || (exports.ProgressToken = ProgressToken = {}));\nvar ProgressNotification;\n(function (ProgressNotification) {\n    ProgressNotification.type = new messages_1.NotificationType('$/progress');\n})(ProgressNotification || (ProgressNotification = {}));\nclass ProgressType {\n    constructor() {\n    }\n}\nexports.ProgressType = ProgressType;\nvar StarRequestHandler;\n(function (StarRequestHandler) {\n    function is(value) {\n        return Is.func(value);\n    }\n    StarRequestHandler.is = is;\n})(StarRequestHandler || (StarRequestHandler = {}));\nexports.NullLogger = Object.freeze({\n    error: () => { },\n    warn: () => { },\n    info: () => { },\n    log: () => { }\n});\nvar Trace;\n(function (Trace) {\n    Trace[Trace[\"Off\"] = 0] = \"Off\";\n    Trace[Trace[\"Messages\"] = 1] = \"Messages\";\n    Trace[Trace[\"Compact\"] = 2] = \"Compact\";\n    Trace[Trace[\"Verbose\"] = 3] = \"Verbose\";\n})(Trace || (exports.Trace = Trace = {}));\nvar TraceValues;\n(function (TraceValues) {\n    /**\n     * Turn tracing off.\n     */\n    TraceValues.Off = 'off';\n    /**\n     * Trace messages only.\n     */\n    TraceValues.Messages = 'messages';\n    /**\n     * Compact message tracing.\n     */\n    TraceValues.Compact = 'compact';\n    /**\n     * Verbose message tracing.\n     */\n    TraceValues.Verbose = 'verbose';\n})(TraceValues || (exports.TraceValues = TraceValues = {}));\n(function (Trace) {\n    function fromString(value) {\n        if (!Is.string(value)) {\n            return Trace.Off;\n        }\n        value = value.toLowerCase();\n        switch (value) {\n            case 'off':\n                return Trace.Off;\n            case 'messages':\n                return Trace.Messages;\n            case 'compact':\n                return Trace.Compact;\n            case 'verbose':\n                return Trace.Verbose;\n            default:\n                return Trace.Off;\n        }\n    }\n    Trace.fromString = fromString;\n    function toString(value) {\n        switch (value) {\n            case Trace.Off:\n                return 'off';\n            case Trace.Messages:\n                return 'messages';\n            case Trace.Compact:\n                return 'compact';\n            case Trace.Verbose:\n                return 'verbose';\n            default:\n                return 'off';\n        }\n    }\n    Trace.toString = toString;\n})(Trace || (exports.Trace = Trace = {}));\nvar TraceFormat;\n(function (TraceFormat) {\n    TraceFormat[\"Text\"] = \"text\";\n    TraceFormat[\"JSON\"] = \"json\";\n})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));\n(function (TraceFormat) {\n    function fromString(value) {\n        if (!Is.string(value)) {\n            return TraceFormat.Text;\n        }\n        value = value.toLowerCase();\n        if (value === 'json') {\n            return TraceFormat.JSON;\n        }\n        else {\n            return TraceFormat.Text;\n        }\n    }\n    TraceFormat.fromString = fromString;\n})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));\nvar SetTraceNotification;\n(function (SetTraceNotification) {\n    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');\n})(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));\nvar LogTraceNotification;\n(function (LogTraceNotification) {\n    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');\n})(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));\nvar ConnectionErrors;\n(function (ConnectionErrors) {\n    /**\n     * The connection is closed.\n     */\n    ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\n    /**\n     * The connection got disposed.\n     */\n    ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\n    /**\n     * The connection is already in listening mode.\n     */\n    ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\n})(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));\nclass ConnectionError extends Error {\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n        Object.setPrototypeOf(this, ConnectionError.prototype);\n    }\n}\nexports.ConnectionError = ConnectionError;\nvar ConnectionStrategy;\n(function (ConnectionStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.cancelUndispatched);\n    }\n    ConnectionStrategy.is = is;\n})(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));\nvar IdCancellationReceiverStrategy;\n(function (IdCancellationReceiverStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));\n    }\n    IdCancellationReceiverStrategy.is = is;\n})(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));\nvar RequestCancellationReceiverStrategy;\n(function (RequestCancellationReceiverStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));\n    }\n    RequestCancellationReceiverStrategy.is = is;\n})(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));\nvar CancellationReceiverStrategy;\n(function (CancellationReceiverStrategy) {\n    CancellationReceiverStrategy.Message = Object.freeze({\n        createCancellationTokenSource(_) {\n            return new cancellation_1.CancellationTokenSource();\n        }\n    });\n    function is(value) {\n        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);\n    }\n    CancellationReceiverStrategy.is = is;\n})(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));\nvar CancellationSenderStrategy;\n(function (CancellationSenderStrategy) {\n    CancellationSenderStrategy.Message = Object.freeze({\n        sendCancellation(conn, id) {\n            return conn.sendNotification(CancelNotification.type, { id });\n        },\n        cleanup(_) { }\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);\n    }\n    CancellationSenderStrategy.is = is;\n})(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));\nvar CancellationStrategy;\n(function (CancellationStrategy) {\n    CancellationStrategy.Message = Object.freeze({\n        receiver: CancellationReceiverStrategy.Message,\n        sender: CancellationSenderStrategy.Message\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);\n    }\n    CancellationStrategy.is = is;\n})(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));\nvar MessageStrategy;\n(function (MessageStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.handleMessage);\n    }\n    MessageStrategy.is = is;\n})(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));\nvar ConnectionOptions;\n(function (ConnectionOptions) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));\n    }\n    ConnectionOptions.is = is;\n})(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));\nvar ConnectionState;\n(function (ConnectionState) {\n    ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\n    ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\n    ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\n    ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\n})(ConnectionState || (ConnectionState = {}));\nfunction createMessageConnection(messageReader, messageWriter, _logger, options) {\n    const logger = _logger !== undefined ? _logger : exports.NullLogger;\n    let sequenceNumber = 0;\n    let notificationSequenceNumber = 0;\n    let unknownResponseSequenceNumber = 0;\n    const version = '2.0';\n    let starRequestHandler = undefined;\n    const requestHandlers = new Map();\n    let starNotificationHandler = undefined;\n    const notificationHandlers = new Map();\n    const progressHandlers = new Map();\n    let timer;\n    let messageQueue = new linkedMap_1.LinkedMap();\n    let responsePromises = new Map();\n    let knownCanceledRequests = new Set();\n    let requestTokens = new Map();\n    let trace = Trace.Off;\n    let traceFormat = TraceFormat.Text;\n    let tracer;\n    let state = ConnectionState.New;\n    const errorEmitter = new events_1.Emitter();\n    const closeEmitter = new events_1.Emitter();\n    const unhandledNotificationEmitter = new events_1.Emitter();\n    const unhandledProgressEmitter = new events_1.Emitter();\n    const disposeEmitter = new events_1.Emitter();\n    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;\n    function createRequestQueueKey(id) {\n        if (id === null) {\n            throw new Error(`Can't send requests with id null since the response can't be correlated.`);\n        }\n        return 'req-' + id.toString();\n    }\n    function createResponseQueueKey(id) {\n        if (id === null) {\n            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();\n        }\n        else {\n            return 'res-' + id.toString();\n        }\n    }\n    function createNotificationQueueKey() {\n        return 'not-' + (++notificationSequenceNumber).toString();\n    }\n    function addMessageToQueue(queue, message) {\n        if (messages_1.Message.isRequest(message)) {\n            queue.set(createRequestQueueKey(message.id), message);\n        }\n        else if (messages_1.Message.isResponse(message)) {\n            queue.set(createResponseQueueKey(message.id), message);\n        }\n        else {\n            queue.set(createNotificationQueueKey(), message);\n        }\n    }\n    function cancelUndispatched(_message) {\n        return undefined;\n    }\n    function isListening() {\n        return state === ConnectionState.Listening;\n    }\n    function isClosed() {\n        return state === ConnectionState.Closed;\n    }\n    function isDisposed() {\n        return state === ConnectionState.Disposed;\n    }\n    function closeHandler() {\n        if (state === ConnectionState.New || state === ConnectionState.Listening) {\n            state = ConnectionState.Closed;\n            closeEmitter.fire(undefined);\n        }\n        // If the connection is disposed don't sent close events.\n    }\n    function readErrorHandler(error) {\n        errorEmitter.fire([error, undefined, undefined]);\n    }\n    function writeErrorHandler(data) {\n        errorEmitter.fire(data);\n    }\n    messageReader.onClose(closeHandler);\n    messageReader.onError(readErrorHandler);\n    messageWriter.onClose(closeHandler);\n    messageWriter.onError(writeErrorHandler);\n    function triggerMessageQueue() {\n        if (timer || messageQueue.size === 0) {\n            return;\n        }\n        timer = (0, ral_1.default)().timer.setImmediate(() => {\n            timer = undefined;\n            processMessageQueue();\n        });\n    }\n    function handleMessage(message) {\n        if (messages_1.Message.isRequest(message)) {\n            handleRequest(message);\n        }\n        else if (messages_1.Message.isNotification(message)) {\n            handleNotification(message);\n        }\n        else if (messages_1.Message.isResponse(message)) {\n            handleResponse(message);\n        }\n        else {\n            handleInvalidMessage(message);\n        }\n    }\n    function processMessageQueue() {\n        if (messageQueue.size === 0) {\n            return;\n        }\n        const message = messageQueue.shift();\n        try {\n            const messageStrategy = options?.messageStrategy;\n            if (MessageStrategy.is(messageStrategy)) {\n                messageStrategy.handleMessage(message, handleMessage);\n            }\n            else {\n                handleMessage(message);\n            }\n        }\n        finally {\n            triggerMessageQueue();\n        }\n    }\n    const callback = (message) => {\n        try {\n            // We have received a cancellation message. Check if the message is still in the queue\n            // and cancel it if allowed to do so.\n            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {\n                const cancelId = message.params.id;\n                const key = createRequestQueueKey(cancelId);\n                const toCancel = messageQueue.get(key);\n                if (messages_1.Message.isRequest(toCancel)) {\n                    const strategy = options?.connectionStrategy;\n                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\n                    if (response && (response.error !== undefined || response.result !== undefined)) {\n                        messageQueue.delete(key);\n                        requestTokens.delete(cancelId);\n                        response.id = toCancel.id;\n                        traceSendingResponse(response, message.method, Date.now());\n                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));\n                        return;\n                    }\n                }\n                const cancellationToken = requestTokens.get(cancelId);\n                // The request is already running. Cancel the token\n                if (cancellationToken !== undefined) {\n                    cancellationToken.cancel();\n                    traceReceivedNotification(message);\n                    return;\n                }\n                else {\n                    // Remember the cancel but still queue the message to\n                    // clean up state in process message.\n                    knownCanceledRequests.add(cancelId);\n                }\n            }\n            addMessageToQueue(messageQueue, message);\n        }\n        finally {\n            triggerMessageQueue();\n        }\n    };\n    function handleRequest(requestMessage) {\n        if (isDisposed()) {\n            // we return here silently since we fired an event when the\n            // connection got disposed.\n            return;\n        }\n        function reply(resultOrError, method, startTime) {\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id\n            };\n            if (resultOrError instanceof messages_1.ResponseError) {\n                message.error = resultOrError.toJson();\n            }\n            else {\n                message.result = resultOrError === undefined ? null : resultOrError;\n            }\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n        }\n        function replyError(error, method, startTime) {\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id,\n                error: error.toJson()\n            };\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n        }\n        function replySuccess(result, method, startTime) {\n            // The JSON RPC defines that a response must either have a result or an error\n            // So we can't treat undefined as a valid response result.\n            if (result === undefined) {\n                result = null;\n            }\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id,\n                result: result\n            };\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n        }\n        traceReceivedRequest(requestMessage);\n        const element = requestHandlers.get(requestMessage.method);\n        let type;\n        let requestHandler;\n        if (element) {\n            type = element.type;\n            requestHandler = element.handler;\n        }\n        const startTime = Date.now();\n        if (requestHandler || starRequestHandler) {\n            const tokenKey = requestMessage.id ?? String(Date.now()); //\n            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver)\n                ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey)\n                : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);\n            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {\n                cancellationSource.cancel();\n            }\n            if (requestMessage.id !== null) {\n                requestTokens.set(tokenKey, cancellationSource);\n            }\n            try {\n                let handlerResult;\n                if (requestHandler) {\n                    if (requestMessage.params === undefined) {\n                        if (type !== undefined && type.numberOfParams !== 0) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(cancellationSource.token);\n                    }\n                    else if (Array.isArray(requestMessage.params)) {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);\n                    }\n                    else {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);\n                    }\n                }\n                else if (starRequestHandler) {\n                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\n                }\n                const promise = handlerResult;\n                if (!handlerResult) {\n                    requestTokens.delete(tokenKey);\n                    replySuccess(handlerResult, requestMessage.method, startTime);\n                }\n                else if (promise.then) {\n                    promise.then((resultOrError) => {\n                        requestTokens.delete(tokenKey);\n                        reply(resultOrError, requestMessage.method, startTime);\n                    }, error => {\n                        requestTokens.delete(tokenKey);\n                        if (error instanceof messages_1.ResponseError) {\n                            replyError(error, requestMessage.method, startTime);\n                        }\n                        else if (error && Is.string(error.message)) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n                        }\n                        else {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n                        }\n                    });\n                }\n                else {\n                    requestTokens.delete(tokenKey);\n                    reply(handlerResult, requestMessage.method, startTime);\n                }\n            }\n            catch (error) {\n                requestTokens.delete(tokenKey);\n                if (error instanceof messages_1.ResponseError) {\n                    reply(error, requestMessage.method, startTime);\n                }\n                else if (error && Is.string(error.message)) {\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n                }\n                else {\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n                }\n            }\n        }\n        else {\n            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\n        }\n    }\n    function handleResponse(responseMessage) {\n        if (isDisposed()) {\n            // See handle request.\n            return;\n        }\n        if (responseMessage.id === null) {\n            if (responseMessage.error) {\n                logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\n            }\n            else {\n                logger.error(`Received response message without id. No further error information provided.`);\n            }\n        }\n        else {\n            const key = responseMessage.id;\n            const responsePromise = responsePromises.get(key);\n            traceReceivedResponse(responseMessage, responsePromise);\n            if (responsePromise !== undefined) {\n                responsePromises.delete(key);\n                try {\n                    if (responseMessage.error) {\n                        const error = responseMessage.error;\n                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\n                    }\n                    else if (responseMessage.result !== undefined) {\n                        responsePromise.resolve(responseMessage.result);\n                    }\n                    else {\n                        throw new Error('Should never happen.');\n                    }\n                }\n                catch (error) {\n                    if (error.message) {\n                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\n                    }\n                    else {\n                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\n                    }\n                }\n            }\n        }\n    }\n    function handleNotification(message) {\n        if (isDisposed()) {\n            // See handle request.\n            return;\n        }\n        let type = undefined;\n        let notificationHandler;\n        if (message.method === CancelNotification.type.method) {\n            const cancelId = message.params.id;\n            knownCanceledRequests.delete(cancelId);\n            traceReceivedNotification(message);\n            return;\n        }\n        else {\n            const element = notificationHandlers.get(message.method);\n            if (element) {\n                notificationHandler = element.handler;\n                type = element.type;\n            }\n        }\n        if (notificationHandler || starNotificationHandler) {\n            try {\n                traceReceivedNotification(message);\n                if (notificationHandler) {\n                    if (message.params === undefined) {\n                        if (type !== undefined) {\n                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {\n                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);\n                            }\n                        }\n                        notificationHandler();\n                    }\n                    else if (Array.isArray(message.params)) {\n                        // There are JSON-RPC libraries that send progress message as positional params although\n                        // specified as named. So convert them if this is the case.\n                        const params = message.params;\n                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {\n                            notificationHandler({ token: params[0], value: params[1] });\n                        }\n                        else {\n                            if (type !== undefined) {\n                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {\n                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);\n                                }\n                                if (type.numberOfParams !== message.params.length) {\n                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);\n                                }\n                            }\n                            notificationHandler(...params);\n                        }\n                    }\n                    else {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);\n                        }\n                        notificationHandler(message.params);\n                    }\n                }\n                else if (starNotificationHandler) {\n                    starNotificationHandler(message.method, message.params);\n                }\n            }\n            catch (error) {\n                if (error.message) {\n                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\n                }\n                else {\n                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\n                }\n            }\n        }\n        else {\n            unhandledNotificationEmitter.fire(message);\n        }\n    }\n    function handleInvalidMessage(message) {\n        if (!message) {\n            logger.error('Received empty message.');\n            return;\n        }\n        logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`);\n        // Test whether we find an id to reject the promise\n        const responseMessage = message;\n        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\n            const key = responseMessage.id;\n            const responseHandler = responsePromises.get(key);\n            if (responseHandler) {\n                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\n            }\n        }\n    }\n    function stringifyTrace(params) {\n        if (params === undefined || params === null) {\n            return undefined;\n        }\n        switch (trace) {\n            case Trace.Verbose:\n                return JSON.stringify(params, null, 4);\n            case Trace.Compact:\n                return JSON.stringify(params);\n            default:\n                return undefined;\n        }\n    }\n    function traceSendingRequest(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {\n                data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n            }\n            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\n        }\n        else {\n            logLSPMessage('send-request', message);\n        }\n    }\n    function traceSendingNotification(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.params) {\n                    data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n                }\n                else {\n                    data = 'No parameters provided.\\n\\n';\n                }\n            }\n            tracer.log(`Sending notification '${message.method}'.`, data);\n        }\n        else {\n            logLSPMessage('send-notification', message);\n        }\n    }\n    function traceSendingResponse(message, method, startTime) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.error && message.error.data) {\n                    data = `Error data: ${stringifyTrace(message.error.data)}\\n\\n`;\n                }\n                else {\n                    if (message.result) {\n                        data = `Result: ${stringifyTrace(message.result)}\\n\\n`;\n                    }\n                    else if (message.error === undefined) {\n                        data = 'No result returned.\\n\\n';\n                    }\n                }\n            }\n            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\n        }\n        else {\n            logLSPMessage('send-response', message);\n        }\n    }\n    function traceReceivedRequest(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {\n                data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n            }\n            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\n        }\n        else {\n            logLSPMessage('receive-request', message);\n        }\n    }\n    function traceReceivedNotification(message) {\n        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.params) {\n                    data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n                }\n                else {\n                    data = 'No parameters provided.\\n\\n';\n                }\n            }\n            tracer.log(`Received notification '${message.method}'.`, data);\n        }\n        else {\n            logLSPMessage('receive-notification', message);\n        }\n    }\n    function traceReceivedResponse(message, responsePromise) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.error && message.error.data) {\n                    data = `Error data: ${stringifyTrace(message.error.data)}\\n\\n`;\n                }\n                else {\n                    if (message.result) {\n                        data = `Result: ${stringifyTrace(message.result)}\\n\\n`;\n                    }\n                    else if (message.error === undefined) {\n                        data = 'No result returned.\\n\\n';\n                    }\n                }\n            }\n            if (responsePromise) {\n                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\n                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\n            }\n            else {\n                tracer.log(`Received response ${message.id} without active response promise.`, data);\n            }\n        }\n        else {\n            logLSPMessage('receive-response', message);\n        }\n    }\n    function logLSPMessage(type, message) {\n        if (!tracer || trace === Trace.Off) {\n            return;\n        }\n        const lspMessage = {\n            isLSPMessage: true,\n            type,\n            message,\n            timestamp: Date.now()\n        };\n        tracer.log(lspMessage);\n    }\n    function throwIfClosedOrDisposed() {\n        if (isClosed()) {\n            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\n        }\n        if (isDisposed()) {\n            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\n        }\n    }\n    function throwIfListening() {\n        if (isListening()) {\n            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\n        }\n    }\n    function throwIfNotListening() {\n        if (!isListening()) {\n            throw new Error('Call listen() first.');\n        }\n    }\n    function undefinedToNull(param) {\n        if (param === undefined) {\n            return null;\n        }\n        else {\n            return param;\n        }\n    }\n    function nullToUndefined(param) {\n        if (param === null) {\n            return undefined;\n        }\n        else {\n            return param;\n        }\n    }\n    function isNamedParam(param) {\n        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';\n    }\n    function computeSingleParam(parameterStructures, param) {\n        switch (parameterStructures) {\n            case messages_1.ParameterStructures.auto:\n                if (isNamedParam(param)) {\n                    return nullToUndefined(param);\n                }\n                else {\n                    return [undefinedToNull(param)];\n                }\n            case messages_1.ParameterStructures.byName:\n                if (!isNamedParam(param)) {\n                    throw new Error(`Received parameters by name but param is not an object literal.`);\n                }\n                return nullToUndefined(param);\n            case messages_1.ParameterStructures.byPosition:\n                return [undefinedToNull(param)];\n            default:\n                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);\n        }\n    }\n    function computeMessageParams(type, params) {\n        let result;\n        const numberOfParams = type.numberOfParams;\n        switch (numberOfParams) {\n            case 0:\n                result = undefined;\n                break;\n            case 1:\n                result = computeSingleParam(type.parameterStructures, params[0]);\n                break;\n            default:\n                result = [];\n                for (let i = 0; i < params.length && i < numberOfParams; i++) {\n                    result.push(undefinedToNull(params[i]));\n                }\n                if (params.length < numberOfParams) {\n                    for (let i = params.length; i < numberOfParams; i++) {\n                        result.push(null);\n                    }\n                }\n                break;\n        }\n        return result;\n    }\n    const connection = {\n        sendNotification: (type, ...args) => {\n            throwIfClosedOrDisposed();\n            let method;\n            let messageParams;\n            if (Is.string(type)) {\n                method = type;\n                const first = args[0];\n                let paramStart = 0;\n                let parameterStructures = messages_1.ParameterStructures.auto;\n                if (messages_1.ParameterStructures.is(first)) {\n                    paramStart = 1;\n                    parameterStructures = first;\n                }\n                let paramEnd = args.length;\n                const numberOfParams = paramEnd - paramStart;\n                switch (numberOfParams) {\n                    case 0:\n                        messageParams = undefined;\n                        break;\n                    case 1:\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n                        break;\n                    default:\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\n                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);\n                        }\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n                        break;\n                }\n            }\n            else {\n                const params = args;\n                method = type.method;\n                messageParams = computeMessageParams(type, params);\n            }\n            const notificationMessage = {\n                jsonrpc: version,\n                method: method,\n                params: messageParams\n            };\n            traceSendingNotification(notificationMessage);\n            return messageWriter.write(notificationMessage).catch((error) => {\n                logger.error(`Sending notification failed.`);\n                throw error;\n            });\n        },\n        onNotification: (type, handler) => {\n            throwIfClosedOrDisposed();\n            let method;\n            if (Is.func(type)) {\n                starNotificationHandler = type;\n            }\n            else if (handler) {\n                if (Is.string(type)) {\n                    method = type;\n                    notificationHandlers.set(type, { type: undefined, handler });\n                }\n                else {\n                    method = type.method;\n                    notificationHandlers.set(type.method, { type, handler });\n                }\n            }\n            return {\n                dispose: () => {\n                    if (method !== undefined) {\n                        notificationHandlers.delete(method);\n                    }\n                    else {\n                        starNotificationHandler = undefined;\n                    }\n                }\n            };\n        },\n        onProgress: (_type, token, handler) => {\n            if (progressHandlers.has(token)) {\n                throw new Error(`Progress handler for token ${token} already registered`);\n            }\n            progressHandlers.set(token, handler);\n            return {\n                dispose: () => {\n                    progressHandlers.delete(token);\n                }\n            };\n        },\n        sendProgress: (_type, token, value) => {\n            // This should not await but simple return to ensure that we don't have another\n            // async scheduling. Otherwise one send could overtake another send.\n            return connection.sendNotification(ProgressNotification.type, { token, value });\n        },\n        onUnhandledProgress: unhandledProgressEmitter.event,\n        sendRequest: (type, ...args) => {\n            throwIfClosedOrDisposed();\n            throwIfNotListening();\n            let method;\n            let messageParams;\n            let token = undefined;\n            if (Is.string(type)) {\n                method = type;\n                const first = args[0];\n                const last = args[args.length - 1];\n                let paramStart = 0;\n                let parameterStructures = messages_1.ParameterStructures.auto;\n                if (messages_1.ParameterStructures.is(first)) {\n                    paramStart = 1;\n                    parameterStructures = first;\n                }\n                let paramEnd = args.length;\n                if (cancellation_1.CancellationToken.is(last)) {\n                    paramEnd = paramEnd - 1;\n                    token = last;\n                }\n                const numberOfParams = paramEnd - paramStart;\n                switch (numberOfParams) {\n                    case 0:\n                        messageParams = undefined;\n                        break;\n                    case 1:\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n                        break;\n                    default:\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\n                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);\n                        }\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n                        break;\n                }\n            }\n            else {\n                const params = args;\n                method = type.method;\n                messageParams = computeMessageParams(type, params);\n                const numberOfParams = type.numberOfParams;\n                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\n            }\n            const id = sequenceNumber++;\n            let disposable;\n            if (token) {\n                disposable = token.onCancellationRequested(() => {\n                    const p = cancellationStrategy.sender.sendCancellation(connection, id);\n                    if (p === undefined) {\n                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);\n                        return Promise.resolve();\n                    }\n                    else {\n                        return p.catch(() => {\n                            logger.log(`Sending cancellation messages for id ${id} failed`);\n                        });\n                    }\n                });\n            }\n            const requestMessage = {\n                jsonrpc: version,\n                id: id,\n                method: method,\n                params: messageParams\n            };\n            traceSendingRequest(requestMessage);\n            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {\n                cancellationStrategy.sender.enableCancellation(requestMessage);\n            }\n            return new Promise(async (resolve, reject) => {\n                const resolveWithCleanup = (r) => {\n                    resolve(r);\n                    cancellationStrategy.sender.cleanup(id);\n                    disposable?.dispose();\n                };\n                const rejectWithCleanup = (r) => {\n                    reject(r);\n                    cancellationStrategy.sender.cleanup(id);\n                    disposable?.dispose();\n                };\n                const responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };\n                try {\n                    await messageWriter.write(requestMessage);\n                    responsePromises.set(id, responsePromise);\n                }\n                catch (error) {\n                    logger.error(`Sending request failed.`);\n                    // Writing the message failed. So we need to reject the promise.\n                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));\n                    throw error;\n                }\n            });\n        },\n        onRequest: (type, handler) => {\n            throwIfClosedOrDisposed();\n            let method = null;\n            if (StarRequestHandler.is(type)) {\n                method = undefined;\n                starRequestHandler = type;\n            }\n            else if (Is.string(type)) {\n                method = null;\n                if (handler !== undefined) {\n                    method = type;\n                    requestHandlers.set(type, { handler: handler, type: undefined });\n                }\n            }\n            else {\n                if (handler !== undefined) {\n                    method = type.method;\n                    requestHandlers.set(type.method, { type, handler });\n                }\n            }\n            return {\n                dispose: () => {\n                    if (method === null) {\n                        return;\n                    }\n                    if (method !== undefined) {\n                        requestHandlers.delete(method);\n                    }\n                    else {\n                        starRequestHandler = undefined;\n                    }\n                }\n            };\n        },\n        hasPendingResponse: () => {\n            return responsePromises.size > 0;\n        },\n        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {\n            let _sendNotification = false;\n            let _traceFormat = TraceFormat.Text;\n            if (sendNotificationOrTraceOptions !== undefined) {\n                if (Is.boolean(sendNotificationOrTraceOptions)) {\n                    _sendNotification = sendNotificationOrTraceOptions;\n                }\n                else {\n                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\n                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\n                }\n            }\n            trace = _value;\n            traceFormat = _traceFormat;\n            if (trace === Trace.Off) {\n                tracer = undefined;\n            }\n            else {\n                tracer = _tracer;\n            }\n            if (_sendNotification && !isClosed() && !isDisposed()) {\n                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });\n            }\n        },\n        onError: errorEmitter.event,\n        onClose: closeEmitter.event,\n        onUnhandledNotification: unhandledNotificationEmitter.event,\n        onDispose: disposeEmitter.event,\n        end: () => {\n            messageWriter.end();\n        },\n        dispose: () => {\n            if (isDisposed()) {\n                return;\n            }\n            state = ConnectionState.Disposed;\n            disposeEmitter.fire(undefined);\n            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');\n            for (const promise of responsePromises.values()) {\n                promise.reject(error);\n            }\n            responsePromises = new Map();\n            requestTokens = new Map();\n            knownCanceledRequests = new Set();\n            messageQueue = new linkedMap_1.LinkedMap();\n            // Test for backwards compatibility\n            if (Is.func(messageWriter.dispose)) {\n                messageWriter.dispose();\n            }\n            if (Is.func(messageReader.dispose)) {\n                messageReader.dispose();\n            }\n        },\n        listen: () => {\n            throwIfClosedOrDisposed();\n            throwIfListening();\n            state = ConnectionState.Listening;\n            messageReader.listen(callback);\n        },\n        inspect: () => {\n            // eslint-disable-next-line no-console\n            (0, ral_1.default)().console.log('inspect');\n        }\n    };\n    connection.onNotification(LogTraceNotification.type, (params) => {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        const verbose = trace === Trace.Verbose || trace === Trace.Compact;\n        tracer.log(params.message, verbose ? params.verbose : undefined);\n    });\n    connection.onNotification(ProgressNotification.type, (params) => {\n        const handler = progressHandlers.get(params.token);\n        if (handler) {\n            handler(params.value);\n        }\n        else {\n            unhandledProgressEmitter.fire(params);\n        }\n    });\n    return connection;\n}\nexports.createMessageConnection = createMessageConnection;\n","\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractMessageBuffer = void 0;\nconst CR = 13;\nconst LF = 10;\nconst CRLF = '\\r\\n';\nclass AbstractMessageBuffer {\n    constructor(encoding = 'utf-8') {\n        this._encoding = encoding;\n        this._chunks = [];\n        this._totalLength = 0;\n    }\n    get encoding() {\n        return this._encoding;\n    }\n    append(chunk) {\n        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;\n        this._chunks.push(toAppend);\n        this._totalLength += toAppend.byteLength;\n    }\n    tryReadHeaders(lowerCaseKeys = false) {\n        if (this._chunks.length === 0) {\n            return undefined;\n        }\n        let state = 0;\n        let chunkIndex = 0;\n        let offset = 0;\n        let chunkBytesRead = 0;\n        row: while (chunkIndex < this._chunks.length) {\n            const chunk = this._chunks[chunkIndex];\n            offset = 0;\n            column: while (offset < chunk.length) {\n                const value = chunk[offset];\n                switch (value) {\n                    case CR:\n                        switch (state) {\n                            case 0:\n                                state = 1;\n                                break;\n                            case 2:\n                                state = 3;\n                                break;\n                            default:\n                                state = 0;\n                        }\n                        break;\n                    case LF:\n                        switch (state) {\n                            case 1:\n                                state = 2;\n                                break;\n                            case 3:\n                                state = 4;\n                                offset++;\n                                break row;\n                            default:\n                                state = 0;\n                        }\n                        break;\n                    default:\n                        state = 0;\n                }\n                offset++;\n            }\n            chunkBytesRead += chunk.byteLength;\n            chunkIndex++;\n        }\n        if (state !== 4) {\n            return undefined;\n        }\n        // The buffer contains the two CRLF at the end. So we will\n        // have two empty lines after the split at the end as well.\n        const buffer = this._read(chunkBytesRead + offset);\n        const result = new Map();\n        const headers = this.toString(buffer, 'ascii').split(CRLF);\n        if (headers.length < 2) {\n            return result;\n        }\n        for (let i = 0; i < headers.length - 2; i++) {\n            const header = headers[i];\n            const index = header.indexOf(':');\n            if (index === -1) {\n                throw new Error(`Message header must separate key and value using ':'\\n${header}`);\n            }\n            const key = header.substr(0, index);\n            const value = header.substr(index + 1).trim();\n            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);\n        }\n        return result;\n    }\n    tryReadBody(length) {\n        if (this._totalLength < length) {\n            return undefined;\n        }\n        return this._read(length);\n    }\n    get numberOfBytes() {\n        return this._totalLength;\n    }\n    _read(byteCount) {\n        if (byteCount === 0) {\n            return this.emptyBuffer();\n        }\n        if (byteCount > this._totalLength) {\n            throw new Error(`Cannot read so many bytes!`);\n        }\n        if (this._chunks[0].byteLength === byteCount) {\n            // super fast path, precisely first chunk must be returned\n            const chunk = this._chunks[0];\n            this._chunks.shift();\n            this._totalLength -= byteCount;\n            return this.asNative(chunk);\n        }\n        if (this._chunks[0].byteLength > byteCount) {\n            // fast path, the reading is entirely within the first chunk\n            const chunk = this._chunks[0];\n            const result = this.asNative(chunk, byteCount);\n            this._chunks[0] = chunk.slice(byteCount);\n            this._totalLength -= byteCount;\n            return result;\n        }\n        const result = this.allocNative(byteCount);\n        let resultOffset = 0;\n        let chunkIndex = 0;\n        while (byteCount > 0) {\n            const chunk = this._chunks[chunkIndex];\n            if (chunk.byteLength > byteCount) {\n                // this chunk will survive\n                const chunkPart = chunk.slice(0, byteCount);\n                result.set(chunkPart, resultOffset);\n                resultOffset += byteCount;\n                this._chunks[chunkIndex] = chunk.slice(byteCount);\n                this._totalLength -= byteCount;\n                byteCount -= byteCount;\n            }\n            else {\n                // this chunk will be entirely read\n                result.set(chunk, resultOffset);\n                resultOffset += chunk.byteLength;\n                this._chunks.shift();\n                this._totalLength -= chunk.byteLength;\n                byteCount -= chunk.byteLength;\n            }\n        }\n        return result;\n    }\n}\nexports.AbstractMessageBuffer = AbstractMessageBuffer;\n","\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst events_1 = require(\"./events\");\nconst semaphore_1 = require(\"./semaphore\");\nvar MessageReader;\n(function (MessageReader) {\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&\n            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);\n    }\n    MessageReader.is = is;\n})(MessageReader || (exports.MessageReader = MessageReader = {}));\nclass AbstractMessageReader {\n    constructor() {\n        this.errorEmitter = new events_1.Emitter();\n        this.closeEmitter = new events_1.Emitter();\n        this.partialMessageEmitter = new events_1.Emitter();\n    }\n    dispose() {\n        this.errorEmitter.dispose();\n        this.closeEmitter.dispose();\n    }\n    get onError() {\n        return this.errorEmitter.event;\n    }\n    fireError(error) {\n        this.errorEmitter.fire(this.asError(error));\n    }\n    get onClose() {\n        return this.closeEmitter.event;\n    }\n    fireClose() {\n        this.closeEmitter.fire(undefined);\n    }\n    get onPartialMessage() {\n        return this.partialMessageEmitter.event;\n    }\n    firePartialMessage(info) {\n        this.partialMessageEmitter.fire(info);\n    }\n    asError(error) {\n        if (error instanceof Error) {\n            return error;\n        }\n        else {\n            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\n        }\n    }\n}\nexports.AbstractMessageReader = AbstractMessageReader;\nvar ResolvedMessageReaderOptions;\n(function (ResolvedMessageReaderOptions) {\n    function fromOptions(options) {\n        let charset;\n        let result;\n        let contentDecoder;\n        const contentDecoders = new Map();\n        let contentTypeDecoder;\n        const contentTypeDecoders = new Map();\n        if (options === undefined || typeof options === 'string') {\n            charset = options ?? 'utf-8';\n        }\n        else {\n            charset = options.charset ?? 'utf-8';\n            if (options.contentDecoder !== undefined) {\n                contentDecoder = options.contentDecoder;\n                contentDecoders.set(contentDecoder.name, contentDecoder);\n            }\n            if (options.contentDecoders !== undefined) {\n                for (const decoder of options.contentDecoders) {\n                    contentDecoders.set(decoder.name, decoder);\n                }\n            }\n            if (options.contentTypeDecoder !== undefined) {\n                contentTypeDecoder = options.contentTypeDecoder;\n                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\n            }\n            if (options.contentTypeDecoders !== undefined) {\n                for (const decoder of options.contentTypeDecoders) {\n                    contentTypeDecoders.set(decoder.name, decoder);\n                }\n            }\n        }\n        if (contentTypeDecoder === undefined) {\n            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;\n            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\n        }\n        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };\n    }\n    ResolvedMessageReaderOptions.fromOptions = fromOptions;\n})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));\nclass ReadableStreamMessageReader extends AbstractMessageReader {\n    constructor(readable, options) {\n        super();\n        this.readable = readable;\n        this.options = ResolvedMessageReaderOptions.fromOptions(options);\n        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);\n        this._partialMessageTimeout = 10000;\n        this.nextMessageLength = -1;\n        this.messageToken = 0;\n        this.readSemaphore = new semaphore_1.Semaphore(1);\n    }\n    set partialMessageTimeout(timeout) {\n        this._partialMessageTimeout = timeout;\n    }\n    get partialMessageTimeout() {\n        return this._partialMessageTimeout;\n    }\n    listen(callback) {\n        this.nextMessageLength = -1;\n        this.messageToken = 0;\n        this.partialMessageTimer = undefined;\n        this.callback = callback;\n        const result = this.readable.onData((data) => {\n            this.onData(data);\n        });\n        this.readable.onError((error) => this.fireError(error));\n        this.readable.onClose(() => this.fireClose());\n        return result;\n    }\n    onData(data) {\n        try {\n            this.buffer.append(data);\n            while (true) {\n                if (this.nextMessageLength === -1) {\n                    const headers = this.buffer.tryReadHeaders(true);\n                    if (!headers) {\n                        return;\n                    }\n                    const contentLength = headers.get('content-length');\n                    if (!contentLength) {\n                        this.fireError(new Error(`Header must provide a Content-Length property.\\n${JSON.stringify(Object.fromEntries(headers))}`));\n                        return;\n                    }\n                    const length = parseInt(contentLength);\n                    if (isNaN(length)) {\n                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));\n                        return;\n                    }\n                    this.nextMessageLength = length;\n                }\n                const body = this.buffer.tryReadBody(this.nextMessageLength);\n                if (body === undefined) {\n                    /** We haven't received the full message yet. */\n                    this.setPartialMessageTimer();\n                    return;\n                }\n                this.clearPartialMessageTimer();\n                this.nextMessageLength = -1;\n                // Make sure that we convert one received message after the\n                // other. Otherwise it could happen that a decoding of a second\n                // smaller message finished before the decoding of a first larger\n                // message and then we would deliver the second message first.\n                this.readSemaphore.lock(async () => {\n                    const bytes = this.options.contentDecoder !== undefined\n                        ? await this.options.contentDecoder.decode(body)\n                        : body;\n                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);\n                    this.callback(message);\n                }).catch((error) => {\n                    this.fireError(error);\n                });\n            }\n        }\n        catch (error) {\n            this.fireError(error);\n        }\n    }\n    clearPartialMessageTimer() {\n        if (this.partialMessageTimer) {\n            this.partialMessageTimer.dispose();\n            this.partialMessageTimer = undefined;\n        }\n    }\n    setPartialMessageTimer() {\n        this.clearPartialMessageTimer();\n        if (this._partialMessageTimeout <= 0) {\n            return;\n        }\n        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {\n            this.partialMessageTimer = undefined;\n            if (token === this.messageToken) {\n                this.firePartialMessage({ messageToken: token, waitingTime: timeout });\n                this.setPartialMessageTimer();\n            }\n        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);\n    }\n}\nexports.ReadableStreamMessageReader = ReadableStreamMessageReader;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DoComplete = void 0;\nconst vscode_css_languageservice_1 = require(\"@somesass/vscode-css-languageservice\");\nconst colorjs_io_1 = __importDefault(require(\"colorjs.io\"));\nconst sass_1 = require(\"../facts/sass\");\nconst sassdoc_1 = require(\"../facts/sassdoc\");\nconst language_feature_1 = require(\"../language-feature\");\nconst language_services_types_1 = require(\"../language-services-types\");\nconst sass_2 = require(\"../utils/sass\");\nconst sassdoc_2 = require(\"../utils/sassdoc\");\nconst reNewSassdocBlock = /\\/\\/\\/\\s?$/;\nconst reSassdocLine = /\\/\\/\\/\\s/;\nconst reSassDotExt = /\\.s(a|c)ss$/;\nconst rePrivate = /^\\$?[-_].*$/;\nconst reReturn = /^.*@return/;\nconst reEach = /^.*@each .+ in /;\nconst reFor = /^.*@for .+ from /;\nconst reIf = /^.*@if /;\nconst reElseIf = /^.*@else if /;\nconst reWhile = /^.*@while /;\nconst reDebug = /^.*@debug /;\nconst reWarn = /^.*@warn /;\nconst reError = /^.*@error /;\nconst rePropertyValue = /.*:\\s*/;\nconst reEmptyPropertyValue = /.*:\\s*$/;\nconst reQuotedValueInString = /[\"'](?:[^\"'\\\\]|\\\\.)*[\"']/g;\nconst reMixinReference = /.*@include\\s+(.*)/;\nconst reIndentedMixinReference = /.*(@include\\s+|\\+)(.*)/;\nconst reCompletedMixinWithParametersReference = /.*@include\\s+(.*)\\(/;\nconst reCompletedIndentedMixinWithParametersReference = /.*(@include\\s+|\\+)(.*)\\(/;\nconst reComment = /^(.*\\/\\/|.*\\/\\*|\\s*\\*)/;\nconst reSassDoc = /^[\\\\s]*\\/{3}.*$/;\nconst reQuotes = /[\"']/;\nconst rePlaceholder = /@extend\\s+/;\nconst rePlaceholderDeclaration = /^\\s*%/;\nconst rePartialModuleAtRule = /@(?:use|forward|import) [\"']/;\nclass DoComplete extends language_feature_1.LanguageFeature {\n    async doComplete(document, position) {\n        const result = language_services_types_1.CompletionList.create([]);\n        const upstreamLs = this.getUpstreamLanguageServer(document);\n        const context = this.createCompletionContext(document, position);\n        const stylesheet = this.ls.parseStylesheet(document);\n        const offset = document.offsetAt(position);\n        let node = (0, vscode_css_languageservice_1.getNodeAtOffset)(stylesheet, offset);\n        // In a handful of cases we don't get a node because our offset lands on a whitespace of\n        // an incomplete declaration, for instance \"@include \". Try to look back at offset - 1 and\n        // see if we get a node there.\n        if (!node && offset > 0) {\n            node = (0, vscode_css_languageservice_1.getNodeAtOffset)(stylesheet, offset - 1);\n        }\n        if (context.isSassdocContext) {\n            const scanner = this.getScanner(document);\n            let token = scanner.scan();\n            let prevToken = null;\n            while (token.type !== language_services_types_1.TokenType.EOF) {\n                // Lookback is needed to figure out if we should do Sassdoc block completion.\n                // It should happen if we hit a function or mixin declaration with `///`\n                // (and an optional space) as the previous token. If we overshoot offset\n                // and that has not happened we don't really care about the rest of the\n                // document and break out of the loop.\n                if (prevToken && prevToken.offset + prevToken.len > offset) {\n                    break;\n                }\n                // Don't start processing the token until we've reached the token under the cursor\n                if (token.offset + token.len < offset) {\n                    prevToken = token;\n                    token = scanner.scan();\n                    continue;\n                }\n                if (token.type === language_services_types_1.TokenType.AtKeyword) {\n                    const keyword = token.text.toLowerCase();\n                    const isFunction = keyword === \"@function\";\n                    const isMixin = keyword === \"@mixin\";\n                    if (isFunction || isMixin) {\n                        if (prevToken && prevToken.text.match(reNewSassdocBlock)) {\n                            // This makes heavy use of the snippet syntax\n                            if (this.clientCapabilities.textDocument?.completion?.completionItem\n                                ?.snippetSupport) {\n                                const node = (0, vscode_css_languageservice_1.getNodeAtOffset)(stylesheet, token.offset);\n                                if (node &&\n                                    (node instanceof language_services_types_1.MixinDeclaration ||\n                                        node instanceof language_services_types_1.FunctionDeclaration)) {\n                                    const item = this.doSassdocBlockCompletion(document, node);\n                                    result.items.push(item);\n                                }\n                            }\n                        }\n                    }\n                }\n                if (token.type === language_services_types_1.TokenType.Comment &&\n                    token.text.match(reSassdocLine)) {\n                    const beforeCursor = token.text.substring(0, offset - token.offset);\n                    const items = this.doSassdocAnnotationCompletion(beforeCursor);\n                    result.items.push(...items);\n                }\n                if (token.type !== language_services_types_1.TokenType.Newline) {\n                    // ignore newlines in the logic\n                    prevToken = token;\n                }\n                token = scanner.scan();\n            }\n            if (result.items.length > 0) {\n                return result;\n            }\n        }\n        if (context.isCommentContext) {\n            return result;\n        }\n        if (context.isImportContext) {\n            // Upstream includes thing like suggestions based on relative paths\n            // and imports of built-in sass modules like sass:color and sass:math\n            const upstreamResult = await upstreamLs.doComplete2(document, position, stylesheet, this.getDocumentContext());\n            if (upstreamResult.items.length > 0) {\n                result.items.push(...upstreamResult.items);\n            }\n            if (node &&\n                node.parent &&\n                (node.parent instanceof language_services_types_1.Use || node.parent instanceof language_services_types_1.Forward)) {\n                const items = await this.doModuleImportCompletion(document, node);\n                if (items.length > 0) {\n                    result.items.push(...items);\n                }\n            }\n            return result;\n        }\n        if (context.isPlaceholderDeclarationContext) {\n            const items = await this.doPlaceholderDeclarationCompletion(context);\n            if (items.length > 0) {\n                result.items.push(...items);\n            }\n            return result;\n        }\n        if (context.isPlaceholderContext) {\n            const items = await this.doPlaceholderUsageCompletion(document, context);\n            if (items.length > 0) {\n                result.items.push(...items);\n            }\n            return result;\n        }\n        /* Completions for variables, functions and mixins */\n        // At this point we're at `@for ` and will declare a variable.\n        // We don't need suggestions here.\n        const forDeclaration = node instanceof language_services_types_1.ForStatement && !node.hasChildren();\n        if (forDeclaration) {\n            return result;\n        }\n        // At this point we're at `@each ` and will declare a variable.\n        // We don't need suggestions here.\n        const eachDeclaration = node instanceof language_services_types_1.EachStatement && !node.variables?.hasChildren();\n        if (eachDeclaration) {\n            return result;\n        }\n        const links = await this.ls.findDocumentLinks(document);\n        if (context.namespace) {\n            const items = await this.doNamespaceCompletion(document, context);\n            if (items.length > 0) {\n                result.items.push(...items);\n                return result;\n            }\n        }\n        // else {\n        // \t// give suggestions for all @use in case the user is typing one of those\n        //  // unfortunately in VS Code at time of writing this breaks suggestions when\n        //  // manually typing out the namespace. Where without this you get suggestions\n        //  // after typing the dot (ex `module.`), this somehow interferes.\n        //  // Adding result.isIncomplete = true has no effect.  While I'd like to include\n        //  // suggestions for available namespaces, the existing behavior has to work.\n        // \tfor (const link of links) {\n        // \t\tif (link.namespace) {\n        // \t\t\tlet insertText = `${link.namespace}.`;\n        // \t\t\tresult.items.push({\n        // \t\t\t\tlabel: link.namespace,\n        // \t\t\t\tkind: CompletionItemKind.Module,\n        // \t\t\t\tinsertText,\n        // \t\t\t\tcommand: {\n        // \t\t\t\t\ttitle: \"Suggest\",\n        // \t\t\t\t\tcommand: \"editor.action.triggerSuggest\",\n        // \t\t\t\t},\n        // \t\t\t});\n        // \t\t}\n        // \t}\n        // }\n        // We might be looking at a wildcard alias (@use \"./foo\" as *), so check the links and see if we need to go looking\n        const wildcards = [];\n        for (const link of links) {\n            if (link.as === \"*\") {\n                wildcards.push(link);\n            }\n        }\n        if (wildcards.length > 0) {\n            const items = await this.doWildcardCompletion(document, wildcards, {\n                ...context,\n                namespace: \"*\",\n            });\n            if (items.length > 0) {\n                result.items.push(...items);\n            }\n        }\n        const config = this.languageConfiguration(document);\n        // Legacy @import style suggestions\n        if (!config.completion.suggestFromUseOnly) {\n            const documents = this.cache.documents();\n            for (const currentDocument of documents) {\n                if (!config.completion.includeFromCurrentDocument &&\n                    currentDocument.uri === document.uri) {\n                    continue;\n                }\n                const symbols = this.ls.findDocumentSymbols(currentDocument);\n                for (const symbol of symbols) {\n                    const isPrivate = Boolean(symbol.name.match(rePrivate));\n                    if (isPrivate && currentDocument.uri !== document.uri) {\n                        continue;\n                    }\n                    switch (symbol.kind) {\n                        case language_services_types_1.SymbolKind.Variable: {\n                            if (!context.isVariableContext)\n                                break;\n                            const items = await this.doVariableCompletion(currentDocument, context, symbol, isPrivate);\n                            if (items.length > 0) {\n                                result.items.push(...items);\n                            }\n                            break;\n                        }\n                        case language_services_types_1.SymbolKind.Method: {\n                            if (!context.isMixinContext)\n                                break;\n                            const items = await this.doMixinCompletion(document, currentDocument, context, symbol, isPrivate);\n                            if (items.length > 0) {\n                                result.items.push(...items);\n                            }\n                            break;\n                        }\n                        case language_services_types_1.SymbolKind.Function: {\n                            if (!context.isFunctionContext)\n                                break;\n                            const items = await this.doFunctionCompletion(currentDocument, context, symbol, isPrivate);\n                            if (items.length > 0) {\n                                result.items.push(...items);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        if (config.completion.css) {\n            const cssResults = await upstreamLs.doComplete2(document, position, stylesheet, this.getDocumentContext());\n            if (cssResults.items.length > 0) {\n                result.items.push(...cssResults.items);\n            }\n        }\n        return result;\n    }\n    createCompletionContext(document, position) {\n        const text = document.getText();\n        const offset = document.offsetAt(position);\n        let i = offset - 1;\n        while (!\"\\n\\r\".includes(text.charAt(i))) {\n            i--;\n        }\n        const lineBeforePosition = text.substring(i + 1, offset);\n        i = offset - 1;\n        while (i >= 0 && !' \\t\\n\\r\":[()]}/,'.includes(text.charAt(i))) {\n            i--;\n        }\n        const currentWord = text.substring(i + 1, offset);\n        const context = {\n            position,\n            currentWord,\n            lineBeforePosition,\n        };\n        if (rePartialModuleAtRule.test(lineBeforePosition)) {\n            context.isImportContext = true;\n            return context;\n        }\n        if (reSassDoc.test(lineBeforePosition)) {\n            context.isSassdocContext = true;\n            return context;\n        }\n        if (reComment.test(lineBeforePosition)) {\n            context.isCommentContext = true;\n            return context;\n        }\n        if (rePlaceholder.test(lineBeforePosition)) {\n            context.isPlaceholderContext = true;\n            return context;\n        }\n        if (rePlaceholderDeclaration.test(lineBeforePosition)) {\n            context.isPlaceholderDeclarationContext = true;\n            return context;\n        }\n        const isInterpolation = currentWord.includes(\"#{\") || lineBeforePosition.includes(\"#{\");\n        if (isInterpolation) {\n            context.isFunctionContext = true;\n            context.isVariableContext = true;\n        }\n        // Is namespace, e.g. `namespace.$var` or `@include namespace.mixin` or `namespace.func()`\n        context.namespace =\n            currentWord.length === 0 || !currentWord.includes(\".\")\n                ? undefined\n                : currentWord.substring(\n                // Skip #{ if this is interpolation\n                isInterpolation ? currentWord.indexOf(\"{\") + 1 : 0, currentWord.indexOf(\".\", currentWord.indexOf(\"{\") + 1));\n        const isPropertyValue = rePropertyValue.test(lineBeforePosition);\n        const isEmptyValue = reEmptyPropertyValue.test(lineBeforePosition);\n        const isQuotes = reQuotes.test(lineBeforePosition.replace(reQuotedValueInString, \"\"));\n        const isControlFlow = reReturn.test(lineBeforePosition) ||\n            reIf.test(lineBeforePosition) ||\n            reElseIf.test(lineBeforePosition) ||\n            reEach.test(lineBeforePosition) ||\n            reFor.test(lineBeforePosition) ||\n            reWhile.test(lineBeforePosition) ||\n            reDebug.test(lineBeforePosition) ||\n            reError.test(lineBeforePosition) ||\n            reWarn.test(lineBeforePosition);\n        if (isControlFlow) {\n            context.isVariableContext = true;\n            context.isFunctionContext = true;\n            return context;\n        }\n        if (reMixinReference.test(lineBeforePosition)) {\n            context.isMixinContext = true;\n            if (reCompletedMixinWithParametersReference.test(lineBeforePosition)) {\n                context.isMixinContext = false;\n                context.isVariableContext = true;\n                context.isFunctionContext = true;\n            }\n            return context;\n        }\n        else if (document.languageId === \"sass\") {\n            // do the same test for the shorthand + to include mixins in this syntax\n            if (!isPropertyValue &&\n                reIndentedMixinReference.test(lineBeforePosition)) {\n                context.isMixinContext = true;\n                if (reCompletedIndentedMixinWithParametersReference.test(lineBeforePosition)) {\n                    context.isMixinContext = false;\n                    context.isVariableContext = true;\n                    context.isFunctionContext = true;\n                }\n            }\n        }\n        if (isPropertyValue && !isEmptyValue && !isQuotes) {\n            if (context.namespace) {\n                context.isFunctionContext = true;\n                context.isVariableContext = true;\n            }\n            else {\n                context.isVariableContext = currentWord.includes(\"$\");\n                const lastChar = lineBeforePosition.charAt(lineBeforePosition.length - 1);\n                const functionTriggers = \" (+-*%\";\n                if (functionTriggers) {\n                    context.isFunctionContext = functionTriggers.includes(lastChar);\n                }\n            }\n        }\n        else if (isQuotes) {\n            context.isVariableContext = isInterpolation;\n            context.isFunctionContext = isInterpolation;\n        }\n        else {\n            context.isVariableContext =\n                currentWord.startsWith(\"$\") || isInterpolation || isEmptyValue;\n            context.isFunctionContext = isPropertyValue && isEmptyValue;\n        }\n        return context;\n    }\n    async doPlaceholderUsageCompletion(initialDocument, context) {\n        const visited = new Set();\n        const items = [];\n        const result = await this.findInWorkspace((document) => {\n            // keep track of visited to avoid duplicates\n            // if suggestFromUseOnly is false\n            visited.add(document.uri);\n            const symbols = this.ls.findDocumentSymbols(document);\n            const items = [];\n            for (const symbol of symbols) {\n                if (symbol.kind === language_services_types_1.SymbolKind.Class && symbol.name.startsWith(\"%\")) {\n                    const item = this.toPlaceholderCompletionItem(document, context, symbol);\n                    items.push(item);\n                }\n            }\n            return items;\n        }, initialDocument);\n        if (result.length > 0) {\n            items.push(...result);\n        }\n        const config = this.languageConfiguration(initialDocument);\n        if (!config.completion.suggestFromUseOnly) {\n            const documents = this.cache.documents();\n            for (const current of documents) {\n                if (visited.has(current.uri)) {\n                    continue;\n                }\n                const symbols = this.ls.findDocumentSymbols(current);\n                for (const symbol of symbols) {\n                    if (symbol.kind === language_services_types_1.SymbolKind.Class && symbol.name.startsWith(\"%\")) {\n                        const item = this.toPlaceholderCompletionItem(current, context, symbol);\n                        items.push(item);\n                    }\n                }\n            }\n        }\n        return items;\n    }\n    toPlaceholderCompletionItem(document, context, symbol) {\n        let documentation = symbol.name;\n        const sassdoc = (0, sassdoc_2.applySassDoc)(symbol);\n        if (sassdoc) {\n            documentation += `\\n____\\n${sassdoc}`;\n        }\n        const detail = `Placeholder declared in ${this.getFileName(document.uri)}`;\n        const filterText = symbol.name.substring(1);\n        const item = {\n            detail,\n            documentation,\n            filterText,\n            textEdit: vscode_css_languageservice_1.TextEdit.replace(this.getReplaceRange(context), symbol.name),\n            kind: language_services_types_1.CompletionItemKind.Class,\n            insertTextFormat: language_services_types_1.InsertTextFormat.PlainText,\n            label: symbol.name,\n            tags: symbol.sassdoc?.deprecated\n                ? [language_services_types_1.CompletionItemTag.Deprecated]\n                : undefined,\n        };\n        return item;\n    }\n    /**\n     * Make completion items for each `%placeholder` used in an `@extend` statement.\n     * This is useful for workflows where the selectors often change, but the semantics\n     * are stable.\n     *\n     * @see https://github.com/wkillerud/some-sass/issues/49\n     */\n    async doPlaceholderDeclarationCompletion(context) {\n        const items = [];\n        const documents = this.cache.documents();\n        for (const currentDocument of documents) {\n            const symbols = this.ls.findDocumentSymbols(currentDocument);\n            for (const symbol of symbols) {\n                if (symbol.kind === language_services_types_1.SymbolKind.Class) {\n                    if (!symbol.children)\n                        continue;\n                    // cssNavigation should only add these placeholder symbols as children\n                    // if the node parent is an @extend reference, meaning a placeholder usage.\n                    for (const child of symbol.children) {\n                        if (child.kind === language_services_types_1.SymbolKind.Class && child.name.startsWith(\"%\")) {\n                            const filterText = child.name.substring(1);\n                            const item = {\n                                textEdit: vscode_css_languageservice_1.TextEdit.replace(this.getReplaceRange(context), child.name),\n                                filterText,\n                                insertTextFormat: language_services_types_1.InsertTextFormat.PlainText,\n                                kind: language_services_types_1.CompletionItemKind.Class,\n                                label: child.name,\n                            };\n                            items.push(item);\n                        }\n                    }\n                }\n            }\n        }\n        return items;\n    }\n    async doNamespaceCompletion(document, context) {\n        const items = [];\n        const namespace = context.namespace;\n        if (!namespace) {\n            return items;\n        }\n        const links = await this.ls.findDocumentLinks(document);\n        let start = undefined;\n        for (const link of links) {\n            if (link.target &&\n                link.type === language_services_types_1.NodeType.Use &&\n                link.namespace === namespace) {\n                if (link.target.includes(\"sass:\")) {\n                    // Look for matches in built-in namespaces, which do not appear in storage\n                    for (const [builtIn, docs] of Object.entries(sass_1.sassBuiltInModules)) {\n                        if (builtIn === link.target) {\n                            const items = this.doSassBuiltInCompletion(document, context, docs);\n                            return items;\n                        }\n                    }\n                }\n                else {\n                    start = this.cache.getDocument(link.target);\n                }\n                break;\n            }\n        }\n        if (!start) {\n            return items;\n        }\n        const result = await this.findCompletionsInWorkspace(document, context, start);\n        return result;\n    }\n    async doWildcardCompletion(document, wildcards, context) {\n        const items = [];\n        for (const link of wildcards) {\n            const start = this.cache.getDocument(link.target);\n            if (!start)\n                continue;\n            const result = await this.findCompletionsInWorkspace(document, context, start);\n            if (result.length > 0) {\n                items.push(...result);\n            }\n        }\n        return items;\n    }\n    async findCompletionsInWorkspace(document, context, start) {\n        const result = await this.findInWorkspace(async (currentDocument, prefix, hide, show) => {\n            const items = [];\n            const symbols = this.ls.findDocumentSymbols(currentDocument);\n            for (const symbol of symbols) {\n                if (show.length > 0 && !show.includes(symbol.name)) {\n                    continue;\n                }\n                if (hide.includes(symbol.name)) {\n                    continue;\n                }\n                const isPrivate = Boolean(symbol.name.match(rePrivate));\n                if (isPrivate && currentDocument.uri !== document.uri) {\n                    continue;\n                }\n                switch (symbol.kind) {\n                    case language_services_types_1.SymbolKind.Variable: {\n                        if (!context.isVariableContext)\n                            break;\n                        const vars = await this.doVariableCompletion(currentDocument, context, symbol, isPrivate, prefix);\n                        if (vars.length > 0) {\n                            items.push(...vars);\n                        }\n                        break;\n                    }\n                    case language_services_types_1.SymbolKind.Method: {\n                        if (!context.isMixinContext)\n                            break;\n                        const mixs = await this.doMixinCompletion(document, currentDocument, context, symbol, isPrivate, prefix);\n                        if (mixs.length > 0) {\n                            items.push(...mixs);\n                        }\n                        break;\n                    }\n                    case language_services_types_1.SymbolKind.Function: {\n                        if (!context.isFunctionContext)\n                            break;\n                        const funcs = await this.doFunctionCompletion(currentDocument, context, symbol, isPrivate, prefix);\n                        if (funcs.length > 0) {\n                            items.push(...funcs);\n                        }\n                        break;\n                    }\n                }\n            }\n            // check if the document @forwards a sass built-in\n            // since they aren't documents that are visited by findInWorkspace\n            const links = await this.ls.findDocumentLinks(currentDocument);\n            for (let link of links) {\n                if (link.type === language_services_types_1.NodeType.Forward &&\n                    link.target &&\n                    link.target.includes(\"sass:\")) {\n                    // Look for matches in built-in namespaces, which do not appear in storage\n                    for (const [builtIn, docs] of Object.entries(sass_1.sassBuiltInModules)) {\n                        if (builtIn === link.target) {\n                            const suggestions = this.doSassBuiltInCompletion(document, context, docs, link.as ? prefix + link.as : \"\");\n                            items.push(...suggestions);\n                        }\n                    }\n                }\n            }\n            return items;\n        }, start, { lazy: false, depth: 1 });\n        return result;\n    }\n    async doVariableCompletion(document, context, symbol, isPrivate, prefix = \"\") {\n        const rawValue = this.getVariableValue(document, symbol);\n        let value = await this.findValue(document, symbol.selectionRange.start);\n        value = value || rawValue;\n        const color = value ? getColorValue(value) : null;\n        const completionKind = color\n            ? language_services_types_1.CompletionItemKind.Color\n            : language_services_types_1.CompletionItemKind.Variable;\n        // Avoid ending up with namespace.prefix-$variable\n        const label = `$${prefix}${(0, sass_2.asDollarlessVariable)(symbol.name)}`;\n        let documentation = color ||\n            [\n                \"```scss\",\n                `${label}: ${value};${value !== rawValue ? ` // via ${rawValue}` : \"\"}`,\n                \"```\",\n            ].join(\"\\n\") ||\n            \"\";\n        const sassdoc = (0, sassdoc_2.applySassDoc)(symbol);\n        if (sassdoc) {\n            documentation += `\\n____\\n${sassdoc}`;\n        }\n        documentation += `\\n____\\nVariable declared in ${this.getFileName(document.uri)}`;\n        const sortText = isPrivate ? label.replace(/^$[_]/, \"\") : undefined;\n        const item = {\n            commitCharacters: [\";\", \",\"],\n            documentation: completionKind === language_services_types_1.CompletionItemKind.Color\n                ? documentation\n                : {\n                    kind: language_services_types_1.MarkupKind.Markdown,\n                    value: documentation,\n                },\n            kind: completionKind,\n            label,\n            sortText,\n            tags: symbol.sassdoc?.deprecated ? [language_services_types_1.CompletionItemTag.Deprecated] : [],\n        };\n        let insertText = label;\n        if (context.namespace && context.namespace !== \"*\") {\n            insertText = `${context.namespace}.${label}`;\n            item.filterText = `${context.namespace}.${label}`;\n        }\n        const range = this.getReplaceRange(context);\n        item.textEdit = vscode_css_languageservice_1.TextEdit.replace(range, insertText);\n        return [item];\n    }\n    getReplaceRange(context) {\n        const { position, currentWord } = context;\n        const start = language_services_types_1.Position.create(position.line, position.character - currentWord.length);\n        const end = language_services_types_1.Position.create(position.line, start.character + currentWord.length);\n        const interpolation = currentWord.indexOf(\"#{\");\n        if (interpolation !== -1) {\n            // don't replace the interpolation syntax (or what may be before it)\n            start.character = start.character + interpolation + 2;\n        }\n        return vscode_css_languageservice_1.Range.create(start, end);\n    }\n    isEmbedded(initialDocument) {\n        const dotExt = initialDocument.uri.slice(Math.max(0, initialDocument.uri.lastIndexOf(\".\")));\n        const isEmbedded = !dotExt.match(reSassDotExt);\n        return isEmbedded;\n    }\n    async doMixinCompletion(initialDocument, document, context, symbol, isPrivate, prefix = \"\") {\n        const items = [];\n        const snippetSupport = this.clientCapabilities.textDocument?.completion?.completionItem\n            ?.snippetSupport;\n        let label = `${prefix}${symbol.name}`;\n        const { namespace } = context;\n        const filterText = namespace\n            ? namespace !== \"*\"\n                ? `${namespace}.${prefix}${symbol.name}`\n                : `${prefix}${symbol.name}`\n            : symbol.name;\n        const sortText = isPrivate ? label.replace(/^$[_]/, \"\") : undefined;\n        const documentation = {\n            kind: language_services_types_1.MarkupKind.Markdown,\n            value: `\\`\\`\\`scss\\n@mixin ${symbol.name}${symbol.detail || \"()\"}\\n\\`\\`\\``,\n        };\n        const sassdoc = (0, sassdoc_2.applySassDoc)(symbol);\n        if (sassdoc) {\n            documentation.value += `\\n____\\n${sassdoc}`;\n        }\n        documentation.value += `\\n____\\nMixin declared in ${this.getFileName(document.uri)}`;\n        const base = {\n            label,\n            documentation,\n            filterText,\n            sortText,\n            kind: language_services_types_1.CompletionItemKind.Method,\n            insertTextFormat: snippetSupport\n                ? language_services_types_1.InsertTextFormat.Snippet\n                : language_services_types_1.InsertTextFormat.PlainText,\n            tags: symbol.sassdoc?.deprecated ? [language_services_types_1.CompletionItemTag.Deprecated] : [],\n        };\n        let insert = label;\n        if (context.namespace && context.namespace !== \"*\") {\n            insert = `${context.namespace}.${label}`;\n            base.filterText = `${context.namespace}.${label}`;\n        }\n        const config = this.languageConfiguration(initialDocument);\n        const makeCompletionVariants = (insert, detail) => {\n            // Not all mixins have @content, but when they do, be smart about adding brackets\n            // and move the cursor to be ready to add said contents.\n            // Include as separate suggestion since content may not always be needed or wanted.\n            if (config.completion.mixinStyle !== \"bracket\") {\n                items.push({\n                    ...base,\n                    labelDetails: detail ? { detail: `(${detail})` } : undefined,\n                    textEdit: vscode_css_languageservice_1.TextEdit.replace(this.getReplaceRange(context), insert),\n                });\n            }\n            if (snippetSupport &&\n                config.completion.mixinStyle !== \"nobracket\" &&\n                document.languageId === \"scss\") {\n                const insertSnippet = `${insert} {\\n\\t$0\\n}`;\n                items.push({\n                    ...base,\n                    labelDetails: { detail: detail ? `(${detail}) { }` : \" { }\" },\n                    textEdit: vscode_css_languageservice_1.TextEdit.replace(this.getReplaceRange(context), insertSnippet),\n                });\n            }\n        };\n        // In the case of no required parameters, skip details.\n        if (symbol.detail && snippetSupport) {\n            const parameters = getParametersFromDetail(symbol.detail);\n            const requiredParameters = parameters.filter((p) => !p.defaultValue);\n            // If there are required parameters, add a suggestion with only them.\n            if (requiredParameters.length > 0) {\n                const parametersSnippet = requiredParameters\n                    .map((p, i) => mapParameterSnippet(p, i, symbol.sassdoc))\n                    .join(\", \");\n                const detail = requiredParameters\n                    .map((p) => mapParameterSignature(p))\n                    .join(\", \");\n                makeCompletionVariants(`${insert}(${parametersSnippet})`, detail);\n            }\n            // If there are optional parameters, add a suggestion with all parameters.\n            if (requiredParameters.length !== parameters.length) {\n                const parametersSnippet = parameters\n                    .map((p, i) => mapParameterSnippet(p, i, symbol.sassdoc))\n                    .join(\", \");\n                const detail = parameters\n                    .map((p) => mapParameterSignature(p))\n                    .join(\", \");\n                makeCompletionVariants(`${insert}(${parametersSnippet})`, detail);\n            }\n        }\n        else {\n            makeCompletionVariants(insert);\n        }\n        return items;\n    }\n    async doFunctionCompletion(document, context, symbol, isPrivate, prefix = \"\") {\n        const items = [];\n        const snippetSupport = this.clientCapabilities.textDocument?.completion?.completionItem\n            ?.snippetSupport;\n        const label = `${prefix}${symbol.name}`;\n        const { namespace } = context;\n        let filterText = symbol.name;\n        if (namespace) {\n            if (namespace === \"*\") {\n                filterText = `${prefix}${symbol.name}`;\n            }\n            else {\n                filterText = `${namespace}.${prefix}${symbol.name}`;\n            }\n        }\n        const sortText = isPrivate ? label.replace(/^$[_]/, \"\") : undefined;\n        const documentation = {\n            kind: language_services_types_1.MarkupKind.Markdown,\n            value: `\\`\\`\\`scss\\n@function ${symbol.name}${symbol.detail || \"()\"}\\n\\`\\`\\``,\n        };\n        const sassdoc = (0, sassdoc_2.applySassDoc)(symbol);\n        if (sassdoc) {\n            documentation.value += `\\n____\\n${sassdoc}`;\n        }\n        documentation.value += `\\n____\\nFunction declared in ${this.getFileName(document.uri)}`;\n        // If there are required parameters, add a suggestion with only them.\n        // If there are optional parameters, add a suggestion with all parameters.\n        const parameters = getParametersFromDetail(symbol.detail);\n        const requiredParameters = parameters.filter((p) => !p.defaultValue);\n        const parametersSnippet = requiredParameters\n            .map((p, i) => mapParameterSnippet(p, i, symbol.sassdoc))\n            .join(\", \");\n        const detail = requiredParameters\n            .map((p) => mapParameterSignature(p))\n            .join(\", \");\n        const base = {\n            documentation,\n            filterText,\n            label,\n            labelDetails: { detail: `(${detail})` },\n            sortText,\n            insertTextFormat: language_services_types_1.InsertTextFormat.Snippet,\n            kind: language_services_types_1.CompletionItemKind.Function,\n            tags: symbol.sassdoc?.deprecated ? [language_services_types_1.CompletionItemTag.Deprecated] : [],\n        };\n        let insert = label;\n        if (context.namespace && context.namespace !== \"*\") {\n            insert = `${context.namespace}.${label}`;\n            base.filterText = `${context.namespace}.${label}`;\n        }\n        if (!snippetSupport) {\n            const insertText = `${insert}()`;\n            const item = {\n                ...base,\n                textEdit: vscode_css_languageservice_1.TextEdit.replace(this.getReplaceRange(context), insertText),\n                insertTextFormat: language_services_types_1.InsertTextFormat.PlainText,\n            };\n            items.push(item);\n        }\n        else {\n            const insertText = `${insert}(${parametersSnippet})`;\n            const item = {\n                ...base,\n                textEdit: vscode_css_languageservice_1.TextEdit.replace(this.getReplaceRange(context), insertText),\n            };\n            items.push(item);\n            if (requiredParameters.length !== parameters.length) {\n                const parametersSnippet = parameters\n                    .map((p, i) => mapParameterSnippet(p, i, symbol.sassdoc))\n                    .join(\", \");\n                const detail = parameters\n                    .map((p) => mapParameterSignature(p))\n                    .join(\", \");\n                const insertText = `${insert}(${parametersSnippet})`;\n                const item = {\n                    ...base,\n                    labelDetails: { detail: `(${detail})` },\n                    textEdit: vscode_css_languageservice_1.TextEdit.replace(this.getReplaceRange(context), insertText),\n                };\n                items.push(item);\n            }\n        }\n        return items;\n    }\n    doSassBuiltInCompletion(document, context, moduleDocs, prefix = \"\") {\n        const items = [];\n        const snippetSupport = this.clientCapabilities.textDocument?.completion?.completionItem\n            ?.snippetSupport;\n        for (const [name, docs] of Object.entries(moduleDocs.exports)) {\n            const { description, signature, parameterSnippet, returns, deprecated } = docs;\n            const kind = signature\n                ? language_services_types_1.CompletionItemKind.Function\n                : language_services_types_1.CompletionItemKind.Variable;\n            let label = name;\n            if (kind === language_services_types_1.CompletionItemKind.Variable) {\n                // Avoid ending up with namespace.prefix-$variable\n                label = `$${prefix}${(0, sass_2.asDollarlessVariable)(name)}`;\n            }\n            else {\n                label = `${prefix}${name}`;\n            }\n            // Client needs the namespace as part of the text that is matched,\n            const filterText = `${context.namespace}.${label}`;\n            const base = {\n                documentation: {\n                    kind: language_services_types_1.MarkupKind.Markdown,\n                    value: `${description}\\n\\n[Sass documentation](${moduleDocs.reference}#${name})`,\n                },\n                filterText,\n                insertTextFormat: parameterSnippet && snippetSupport\n                    ? language_services_types_1.InsertTextFormat.Snippet\n                    : language_services_types_1.InsertTextFormat.PlainText,\n                kind: signature\n                    ? language_services_types_1.CompletionItemKind.Function\n                    : language_services_types_1.CompletionItemKind.Variable,\n                label,\n                labelDetails: {\n                    detail: signature && returns ? `${signature} => ${returns}` : signature,\n                },\n                tags: deprecated ? [language_services_types_1.CompletionItemTag.Deprecated] : undefined,\n            };\n            const insert = `${context.namespace}.${label}${signature ? `(${snippetSupport ? parameterSnippet : \"\"})` : \"\"}`;\n            items.push({\n                ...base,\n                textEdit: vscode_css_languageservice_1.TextEdit.replace(this.getReplaceRange(context), insert),\n            });\n        }\n        return items;\n    }\n    async doModuleImportCompletion(document, node) {\n        const items = [];\n        const url = node.getText().replace(/[\"']/g, \"\");\n        const moduleName = getModuleNameFromPath(url);\n        const rootFolderUri = this.configuration.workspace.workspaceRoot\n            ? language_services_types_1.Utils.joinPath(this.configuration.workspace.workspaceRoot, \"/\").toString(true)\n            : \"\";\n        const documentFolderUri = language_services_types_1.Utils.dirname(language_services_types_1.URI.parse(document.uri)).toString(true);\n        if (moduleName && moduleName !== \".\" && moduleName !== \"..\") {\n            const modulePath = await this.resolvePathToModule(moduleName, documentFolderUri, rootFolderUri);\n            if (modulePath) {\n                const pathWithinModule = url.substring(moduleName.length + 1);\n                const pathInsideModule = language_services_types_1.Utils.joinPath(language_services_types_1.URI.parse(modulePath), pathWithinModule);\n                const filesInModulePath = await this.options.fileSystemProvider.readDirectory(pathInsideModule);\n                for (const [name, fileType] of filesInModulePath) {\n                    const file = name;\n                    if (fileType === language_services_types_1.FileType.File && file.match(reSassDotExt)) {\n                        const filename = file.startsWith(\"/\") ? file.slice(1) : file;\n                        // Prefer to insert without file extension\n                        let insertText = filename.slice(0, -5);\n                        if (insertText.startsWith(\"/\")) {\n                            insertText = insertText.slice(1);\n                        }\n                        if (insertText.startsWith(\"_\")) {\n                            insertText = insertText.slice(1);\n                        }\n                        items.push({\n                            label: escapePath(filename),\n                            insertText: escapePath(insertText),\n                            kind: language_services_types_1.CompletionItemKind.File,\n                        });\n                    }\n                    else if (fileType === language_services_types_1.FileType.Directory) {\n                        let insertText = escapePath(file);\n                        if (insertText.startsWith(\"/\")) {\n                            insertText = insertText.slice(1);\n                        }\n                        insertText = `${insertText}/`;\n                        items.push({\n                            label: insertText,\n                            kind: language_services_types_1.CompletionItemKind.Folder,\n                            insertText,\n                            command: {\n                                title: \"Suggest\",\n                                command: \"editor.action.triggerSuggest\",\n                            },\n                        });\n                    }\n                }\n            }\n        }\n        if (!moduleName && url === \"pkg:\") {\n            // Find the way to the nearest node_modules and list entries.\n            // This won't cover all scenarios (like workspaces) or package managers, but\n            // is better than nothing.\n            const nodeModules = await this.resolvePathToNodeModules(documentFolderUri, rootFolderUri);\n            if (nodeModules) {\n                const folders = await this.options.fileSystemProvider.readDirectory(nodeModules);\n                for (const [name, fileType] of folders) {\n                    if (name.startsWith(\".\"))\n                        continue;\n                    if (fileType === language_services_types_1.FileType.Directory) {\n                        let insertText = escapePath(name);\n                        if (insertText.startsWith(\"/\")) {\n                            insertText = insertText.slice(1);\n                        }\n                        insertText = `${insertText}`;\n                        items.push({\n                            label: insertText,\n                            kind: language_services_types_1.CompletionItemKind.Folder,\n                            insertText,\n                            command: {\n                                title: \"Suggest\",\n                                command: \"editor.action.triggerSuggest\",\n                            },\n                        });\n                    }\n                }\n            }\n        }\n        return items;\n    }\n    async resolvePathToModule(_moduleName, documentFolderUri, rootFolderUri) {\n        // resolve the module relative to the document. We can't use `require` here as the code is webpacked.\n        const packPath = language_services_types_1.Utils.joinPath(language_services_types_1.URI.parse(documentFolderUri), \"node_modules\", _moduleName, \"package.json\");\n        if (await this.options.fileSystemProvider.exists(packPath)) {\n            return language_services_types_1.Utils.dirname(packPath).toString(true);\n        }\n        else if (rootFolderUri &&\n            documentFolderUri.startsWith(rootFolderUri) &&\n            documentFolderUri.length !== rootFolderUri.length) {\n            return this.resolvePathToModule(_moduleName, language_services_types_1.Utils.dirname(language_services_types_1.URI.parse(documentFolderUri)).toString(true), rootFolderUri);\n        }\n        return undefined;\n    }\n    async resolvePathToNodeModules(documentFolderUri, rootFolderUri) {\n        // resolve the module relative to the document. We can't use `require` here as the code is webpacked.\n        const dirPath = language_services_types_1.Utils.joinPath(language_services_types_1.URI.parse(documentFolderUri), \"node_modules\");\n        if (await this.options.fileSystemProvider.exists(dirPath)) {\n            return dirPath;\n        }\n        else if (rootFolderUri &&\n            documentFolderUri.startsWith(rootFolderUri) &&\n            documentFolderUri.length !== rootFolderUri.length) {\n            return this.resolvePathToNodeModules(language_services_types_1.Utils.dirname(language_services_types_1.URI.parse(documentFolderUri)).toString(true), rootFolderUri);\n        }\n        return undefined;\n    }\n    doSassdocAnnotationCompletion(beforeCursor) {\n        if (beforeCursor.includes(\"@example\")) {\n            return [\n                {\n                    label: \"scss\",\n                    sortText: \"-\", // Give highest priority\n                    kind: language_services_types_1.CompletionItemKind.Value,\n                },\n                {\n                    label: \"css\",\n                    kind: language_services_types_1.CompletionItemKind.Value,\n                },\n                {\n                    label: \"markup\",\n                    kind: language_services_types_1.CompletionItemKind.Value,\n                },\n                {\n                    label: \"javascript\",\n                    sortText: \"y\", // Give lowest priority\n                    kind: language_services_types_1.CompletionItemKind.Value,\n                },\n            ];\n        }\n        const items = [];\n        for (const { annotation, aliases, insertText, insertTextFormat, } of sassdoc_1.sassDocAnnotations) {\n            const item = {\n                label: annotation,\n                kind: language_services_types_1.CompletionItemKind.Keyword,\n                insertText,\n                insertTextFormat,\n                sortText: \"-\", // Give highest priority\n            };\n            items.push(item);\n            if (aliases) {\n                for (const alias of aliases) {\n                    items.push({\n                        ...item,\n                        label: alias,\n                        insertText: insertText\n                            ? insertText.replace(annotation, alias)\n                            : insertText,\n                    });\n                }\n            }\n        }\n        return items;\n    }\n    /**\n     * Generates a suggestion for a Sassdoc block above a mixin or function that includes its parameters.\n     */\n    doSassdocBlockCompletion(document, node) {\n        const isMixin = node.type === language_services_types_1.NodeType.MixinDeclaration;\n        // Incremented when used, starting at position zero below.\n        // This ensures each snippet gets a unique tab position, ending at\n        // position 0 which is the description for the block itself.\n        let position = 0;\n        let snippet = ` \\${${position++}}`; // \" ${0}\"\n        const parameters = node\n            .getParameters()\n            .getChildren();\n        for (const parameter of parameters) {\n            const name = parameter.getName();\n            const defaultValue = parameter.getDefaultValue()?.getText();\n            let typeSnippet = \"type\";\n            let defaultValueSnippet = \"\";\n            if (defaultValue) {\n                defaultValueSnippet = ` [${defaultValue}]`;\n                // Try to give a sensible default type if we can\n                if (defaultValue === \"true\" || defaultValue === \"false\") {\n                    typeSnippet = \"Boolean\";\n                }\n                else if (/^[\"']/.exec(defaultValue)) {\n                    typeSnippet = \"String\";\n                }\n                else if (defaultValue.startsWith(\"#\") ||\n                    defaultValue.startsWith(\"rgb\") ||\n                    defaultValue.startsWith(\"hsl\")) {\n                    typeSnippet = \"Color\";\n                }\n                else {\n                    const maybeNumber = Number.parseFloat(defaultValue);\n                    if (!Number.isNaN(maybeNumber)) {\n                        typeSnippet = \"Number\";\n                    }\n                }\n            }\n            // A parameter snippet such as the one below. The escape sequence \"\\\\${name}\" is needed to get the $ of variable names as part of the snippet output.\n            // \"/// @param {$1:Number} \\$start [0] ${2:-}\"\n            snippet += `\\n/// @param {\\${${position++}:${typeSnippet}}} \\\\${name}${defaultValueSnippet} \\${${position++}:-}`;\n        }\n        if (isMixin) {\n            const text = node.getText();\n            const hasContentAtKeyword = text.includes(\"@content\");\n            if (hasContentAtKeyword) {\n                snippet += `\\n/// @content \\${${position++}}`;\n            }\n            snippet += `\\n/// @output \\${${position++}}`;\n        }\n        else {\n            snippet += `\\n/// @return {\\${${position++}:type}} \\${${position++}:-}`;\n        }\n        return {\n            label: \"SassDoc Block\",\n            insertText: snippet,\n            insertTextFormat: language_services_types_1.InsertTextFormat.Snippet,\n            sortText: \"-\", // Give highest priority\n        };\n    }\n    getModuleNode(document, node) {\n        if (!node)\n            return null;\n        switch (node.type) {\n            case language_services_types_1.NodeType.MixinReference: {\n                const identifier = node.getIdentifier();\n                if (identifier &&\n                    identifier.parent &&\n                    identifier.parent.type === language_services_types_1.NodeType.Module) {\n                    return identifier.parent;\n                }\n                return null;\n            }\n            case language_services_types_1.NodeType.Module: {\n                return node;\n            }\n            case language_services_types_1.NodeType.Identifier: {\n                if (node.parent && node.parent.type === language_services_types_1.NodeType.Module) {\n                    return node.parent;\n                }\n                return null;\n            }\n            default: {\n                const text = node.getText();\n                const interpolationStart = text.indexOf(\"#{\");\n                if (interpolationStart !== -1) {\n                    const dotDelim = text.indexOf(\".\", interpolationStart + 2);\n                    if (dotDelim !== -1) {\n                        const maybeNamespace = text.substring(interpolationStart + 2, dotDelim + 1);\n                        const module = new language_services_types_1.Module(node.offset + interpolationStart + 2, maybeNamespace.length, language_services_types_1.NodeType.Module);\n                        const identifier = new language_services_types_1.Identifier(node.offset + interpolationStart + 2, maybeNamespace.length - 1);\n                        module.setIdentifier(identifier);\n                        module.parent = node; // to get access to textProvider\n                        return module;\n                    }\n                }\n                else if (this.isEmbedded(document)) {\n                    const dotIndex = text.indexOf(\".\");\n                    if (dotIndex !== -1) {\n                        let startOffset = dotIndex;\n                        const endOffset = dotIndex;\n                        while (startOffset > 0) {\n                            const char = text.charAt(startOffset - 1);\n                            if (char.match(/\\s/)) {\n                                break;\n                            }\n                            startOffset -= 1;\n                        }\n                        const module = new language_services_types_1.Module(node.offset + startOffset, endOffset - startOffset, language_services_types_1.NodeType.Module);\n                        const identifier = new language_services_types_1.Identifier(node.offset + startOffset, endOffset - startOffset);\n                        module.setIdentifier(identifier);\n                        module.parent = node; // to get access to textProvider\n                        return module;\n                    }\n                }\n                return null;\n            }\n        }\n    }\n}\nexports.DoComplete = DoComplete;\nfunction getModuleNameFromPath(modulePath) {\n    let path = modulePath;\n    // Slice away deprecated tilde import\n    if (path.startsWith(\"~\")) {\n        path = path.slice(1);\n    }\n    const firstSlash = path.indexOf(\"/\");\n    if (firstSlash === -1) {\n        return \"\";\n    }\n    // If a scoped module (starts with @) then get up until second instance of '/', or to the end of the string for root-level imports.\n    if (path[0] === \"@\") {\n        const secondSlash = path.indexOf(\"/\", firstSlash + 1);\n        if (secondSlash === -1) {\n            return path;\n        }\n        return path.substring(0, secondSlash);\n    }\n    // Otherwise get until first instance of '/'\n    return path.substring(0, firstSlash);\n}\n// Escape https://www.w3.org/TR/CSS1/#url\nfunction escapePath(p) {\n    return p.replace(/(\\s|\\(|\\)|,|\"|')/g, \"\\\\$1\");\n}\nfunction getColorValue(from) {\n    try {\n        colorjs_io_1.default.parse(from);\n        return from;\n    }\n    catch {\n        return null;\n    }\n}\nfunction getParametersFromDetail(detail) {\n    const result = [];\n    if (!detail) {\n        return result;\n    }\n    const parameters = detail.replace(/[()]/g, \"\").split(\",\");\n    for (const param of parameters) {\n        let name = param;\n        let defaultValue = undefined;\n        const defaultValueStart = param.indexOf(\":\");\n        if (defaultValueStart !== -1) {\n            name = param.substring(0, defaultValueStart);\n            defaultValue = param.substring(defaultValueStart + 1);\n        }\n        const parameter = {\n            name: name.trim(),\n            defaultValue: defaultValue?.trim(),\n        };\n        result.push(parameter);\n    }\n    return result;\n}\n/**\n * Use the SnippetString syntax to provide smart completions of parameter names.\n */\nfunction mapParameterSnippet(p, index, sassdoc) {\n    const dollarlessVariable = (0, sass_2.asDollarlessVariable)(p.name);\n    const parameterDocs = sassdoc && sassdoc.parameter\n        ? sassdoc.parameter.find((p) => p.name === dollarlessVariable)\n        : undefined;\n    if (parameterDocs?.type?.length) {\n        const choices = parseStringLiteralChoices(parameterDocs.type);\n        if (choices.length > 0) {\n            return `\\${${index + 1}|${choices.join(\",\")}|}`;\n        }\n    }\n    return `\\${${index + 1}:${dollarlessVariable}}`;\n}\nfunction mapParameterSignature(p) {\n    return p.defaultValue ? `${p.name}: ${p.defaultValue}` : p.name;\n}\nconst reStringLiteral = /^[\"'].+[\"']$/; // Yes, this will match 'foo\", but let the parser deal with yelling about that.\n/**\n * @param docstring A TypeScript-like string of accepted string literal values, for example `\"standard\" | \"entrance\" | \"exit\"`.\n */\nfunction parseStringLiteralChoices(docstring) {\n    const docstrings = typeof docstring === \"string\" ? [docstring] : docstring;\n    const result = [];\n    for (const doc of docstrings) {\n        const parts = doc.split(\"|\");\n        if (parts.length === 1) {\n            // This may be a docstring to indicate only a single valid string literal option.\n            const trimmed = doc.trim();\n            if (reStringLiteral.test(trimmed)) {\n                result.push(trimmed);\n            }\n        }\n        else {\n            for (const part of parts) {\n                const trimmed = part.trim();\n                if (reStringLiteral.test(trimmed)) {\n                    result.push(trimmed);\n                }\n            }\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=do-complete.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DoHover = void 0;\nconst vscode_css_languageservice_1 = require(\"@somesass/vscode-css-languageservice\");\nconst sass_1 = require(\"../facts/sass\");\nconst sassdoc_1 = require(\"../facts/sassdoc\");\nconst language_feature_1 = require(\"../language-feature\");\nconst language_services_types_1 = require(\"../language-services-types\");\nconst sass_2 = require(\"../utils/sass\");\nconst sassdoc_2 = require(\"../utils/sassdoc\");\nclass DoHover extends language_feature_1.LanguageFeature {\n    async doHover(document, position) {\n        const config = this.languageConfiguration(document);\n        const stylesheet = this.ls.parseStylesheet(document);\n        const offset = document.offsetAt(position);\n        let nodeType;\n        const hoverNode = (0, vscode_css_languageservice_1.getNodeAtOffset)(stylesheet, offset);\n        if (hoverNode) {\n            nodeType = hoverNode.type;\n        }\n        else {\n            // If the document begins with a SassDoc comment the Stylesheet node does not begin at offset 0,\n            // instead starting where the SassDoc block ends. To ensure we get down to the switch below to\n            // look for Sassdoc annotations, set nodeType to Stylesheet here.\n            nodeType = language_services_types_1.NodeType.Stylesheet;\n        }\n        let kind;\n        let name;\n        let range = undefined;\n        switch (nodeType) {\n            case language_services_types_1.NodeType.VariableName: {\n                const parent = hoverNode?.getParent();\n                if (parent &&\n                    parent.type !== language_services_types_1.NodeType.VariableDeclaration &&\n                    parent.type !== language_services_types_1.NodeType.FunctionParameter) {\n                    name = hoverNode.getName();\n                    kind = language_services_types_1.SymbolKind.Variable;\n                }\n                break;\n            }\n            case language_services_types_1.NodeType.Identifier: {\n                let node;\n                let type = null;\n                const parent = hoverNode?.getParent();\n                if (parent && parent.type === language_services_types_1.NodeType.Function) {\n                    node = parent;\n                    type = language_services_types_1.SymbolKind.Function;\n                }\n                else if (parent && parent.type === language_services_types_1.NodeType.MixinReference) {\n                    node = parent;\n                    type = language_services_types_1.SymbolKind.Method;\n                }\n                if (type === null) {\n                    if (config.hover.documentation) {\n                        // We are probably hovering over a CSS identifier.\n                        // In VS Code, by default we defer this to vscode-css-languageservice's hover handler.\n                        return this.getUpstreamLanguageServer(document).doHover(document, position, stylesheet);\n                    }\n                    return null;\n                }\n                if (node) {\n                    name = node.getName();\n                    kind = type;\n                }\n                break;\n            }\n            case language_services_types_1.NodeType.MixinReference: {\n                name = hoverNode?.getName();\n                kind = language_services_types_1.SymbolKind.Method;\n                break;\n            }\n            case language_services_types_1.NodeType.Stylesheet: {\n                // Hover information for SassDoc.\n                // SassDoc is considered a comment, which are skipped by the regular parser (so we hit the Stylesheet node).\n                // Use the base scanner to retokenize the document including comments,\n                // and look a comment token at the hover position.\n                const scanner = this.getScanner(document);\n                let token = scanner.scan();\n                while (token.type !== language_services_types_1.TokenType.EOF) {\n                    if (token.offset + token.len < offset) {\n                        token = scanner.scan();\n                        continue;\n                    }\n                    if (token.type === language_services_types_1.TokenType.Comment) {\n                        const commentText = token.text;\n                        const candidate = sassdoc_1.sassDocAnnotations.find(({ annotation, aliases }) => {\n                            return (commentText.includes(annotation) ||\n                                aliases?.some((alias) => commentText.includes(alias)));\n                        });\n                        if (!candidate) {\n                            // No Sassdoc annotations in the comment\n                            break;\n                        }\n                        const annotationStart = token.offset + commentText.indexOf(candidate.annotation) - 1;\n                        const annotationEnd = annotationStart + candidate.annotation.length + 1;\n                        const hoveringAboveAnnotation = annotationEnd > offset && offset > annotationStart;\n                        if (!hoveringAboveAnnotation) {\n                            break;\n                        }\n                        return {\n                            contents: {\n                                kind: language_services_types_1.MarkupKind.Markdown,\n                                value: [\n                                    candidate.annotation,\n                                    config.hover.references\n                                        ? `\\n[SassDoc reference](http://sassdoc.com/annotations/#${candidate.annotation.slice(1)})`\n                                        : \"\",\n                                ]\n                                    .join(\"\\n\")\n                                    .trim(),\n                            },\n                        };\n                    }\n                    token = scanner.scan();\n                }\n                break;\n            }\n            case language_services_types_1.NodeType.SelectorPlaceholder: {\n                name = hoverNode?.getText();\n                kind = language_services_types_1.SymbolKind.Class;\n                break;\n            }\n        }\n        if (hoverNode && name && kind) {\n            range = language_services_types_1.Range.create(document.positionAt(hoverNode.offset), document.positionAt(hoverNode.offset + name.length));\n            // Traverse the workspace looking for a symbol of kinds.includes(symbol.kind) && name === symbol.name\n            const result = await this.findInWorkspace((document, prefix) => {\n                const symbols = this.ls.findDocumentSymbols(document);\n                for (const symbol of symbols) {\n                    if (symbol.kind === kind) {\n                        const prefixedSymbol = `${prefix}${(0, sass_2.asDollarlessVariable)(symbol.name)}`;\n                        const prefixedName = (0, sass_2.asDollarlessVariable)(name);\n                        if (prefixedSymbol === prefixedName) {\n                            return [[document, symbol]];\n                        }\n                    }\n                }\n            }, document, { lazy: true });\n            let symbolDocument = null;\n            let symbol = null;\n            if (result.length !== 0) {\n                [symbolDocument, symbol] = result[0];\n            }\n            else {\n                // Fall back to looking through all the things, assuming folks use @import\n                const documents = this.cache.documents();\n                for (const document of documents) {\n                    const symbols = this.ls.findDocumentSymbols(document);\n                    for (const sym of symbols) {\n                        if (sym.kind === kind && sym.name === name) {\n                            symbolDocument = document;\n                            symbol = sym;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (symbol && symbolDocument) {\n                switch (symbol.kind) {\n                    case language_services_types_1.SymbolKind.Variable: {\n                        const hover = await this.getVariableHoverContent(symbolDocument, symbol, name);\n                        hover.range = range;\n                        return hover;\n                    }\n                    case language_services_types_1.SymbolKind.Method: {\n                        const hover = this.getMixinHoverContent(symbolDocument, symbol, name);\n                        hover.range = range;\n                        return hover;\n                    }\n                    case language_services_types_1.SymbolKind.Function: {\n                        const hover = this.getFunctionHoverContent(symbolDocument, symbol, name);\n                        hover.range = range;\n                        return hover;\n                    }\n                    case language_services_types_1.SymbolKind.Class: {\n                        const hover = this.getPlaceholderHoverContent(symbolDocument, symbol);\n                        hover.range = range;\n                        return hover;\n                    }\n                }\n            }\n        }\n        if (hoverNode) {\n            // Look to see if this is a built-in, but only if we have no other content.\n            // Folks may use the same names as built-ins in their modules.\n            for (const { reference, exports } of Object.values(sass_1.sassBuiltInModules)) {\n                for (const [builtinName, { description }] of Object.entries(exports)) {\n                    if (builtinName === name) {\n                        // Make sure we're not just hovering over a CSS function.\n                        // Confirm we are looking at something that is the child of a module.\n                        const isModule = hoverNode.getParent()?.type === language_services_types_1.NodeType.Module ||\n                            hoverNode.getParent()?.getParent()?.type === language_services_types_1.NodeType.Module;\n                        if (isModule) {\n                            return {\n                                contents: {\n                                    kind: language_services_types_1.MarkupKind.Markdown,\n                                    value: [\n                                        description,\n                                        config.hover.references\n                                            ? `\\n[Sass reference](${reference}#${builtinName})`\n                                            : \"\",\n                                    ]\n                                        .join(\"\\n\")\n                                        .trim(),\n                                },\n                            };\n                        }\n                    }\n                }\n            }\n        }\n        // Lastly, fall back to CSS hover information\n        return this.getUpstreamLanguageServer(document).doHover(document, position, stylesheet);\n    }\n    getFunctionHoverContent(document, symbol, maybePrefixedName) {\n        const result = {\n            kind: language_services_types_1.MarkupKind.Markdown,\n            value: [\n                document.languageId === \"sass\" ? \"```sass\" : \"```scss\",\n                `@function ${maybePrefixedName}${symbol.detail || \"()\"}`,\n                \"```\",\n            ].join(\"\\n\"),\n        };\n        const sassdoc = (0, sassdoc_2.applySassDoc)(symbol);\n        if (sassdoc) {\n            result.value += `\\n____\\n${sassdoc}`;\n        }\n        const prefixInfo = maybePrefixedName !== symbol.name ? ` as ${symbol.name}` : \"\";\n        result.value += `\\n____\\nFunction declared${prefixInfo} in ${this.getFileName(document.uri)}`;\n        return {\n            contents: result,\n        };\n    }\n    getMixinHoverContent(document, symbol, maybePrefixedName) {\n        const result = {\n            kind: language_services_types_1.MarkupKind.Markdown,\n            value: [\n                document.languageId === \"sass\" ? \"```sass\" : \"```scss\",\n                `@mixin ${maybePrefixedName}${symbol.detail || \"()\"}`,\n                \"```\",\n            ].join(\"\\n\"),\n        };\n        const sassdoc = (0, sassdoc_2.applySassDoc)(symbol);\n        if (sassdoc) {\n            result.value += `\\n____\\n${sassdoc}`;\n        }\n        const prefixInfo = maybePrefixedName !== symbol.name ? ` as ${symbol.name}` : \"\";\n        result.value += `\\n____\\nMixin declared${prefixInfo} in ${this.getFileName(document.uri)}`;\n        return {\n            contents: result,\n        };\n    }\n    getPlaceholderHoverContent(document, symbol) {\n        const result = {\n            kind: language_services_types_1.MarkupKind.Markdown,\n            value: [\n                document.languageId === \"sass\" ? \"```sass\" : \"```scss\",\n                symbol.name,\n                \"```\",\n            ].join(\"\\n\"),\n        };\n        const sassdoc = (0, sassdoc_2.applySassDoc)(symbol);\n        if (sassdoc) {\n            result.value += `\\n____\\n${sassdoc}`;\n        }\n        result.value += `\\n____\\nPlaceholder declared in ${this.getFileName(document.uri)}`;\n        return {\n            contents: result,\n        };\n    }\n    async getVariableHoverContent(document, symbol, maybePrefixedName) {\n        const rawValue = this.getVariableValue(document, symbol) || \"\";\n        let value = await this.findValue(document, symbol.selectionRange.start);\n        value = value || rawValue;\n        const result = {\n            kind: language_services_types_1.MarkupKind.Markdown,\n            value: [\n                document.languageId === \"sass\" ? \"```sass\" : \"```scss\",\n                `${maybePrefixedName}: ${value}${document.languageId === \"sass\" ? \"\" : \";\"}${value !== rawValue ? ` // via ${rawValue}` : \"\"}`,\n                \"```\",\n            ].join(\"\\n\"),\n        };\n        const sassdoc = (0, sassdoc_2.applySassDoc)(symbol);\n        if (sassdoc) {\n            result.value += `\\n____\\n${sassdoc}`;\n        }\n        const prefixInfo = maybePrefixedName !== symbol.name ? ` as ${symbol.name}` : \"\";\n        result.value += `\\n____\\nVariable declared${prefixInfo} in ${this.getFileName(document.uri)}`;\n        return {\n            contents: result,\n        };\n    }\n}\nexports.DoHover = DoHover;\n//# sourceMappingURL=do-hover.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DoSignatureHelp = void 0;\nconst vscode_css_languageservice_1 = require(\"@somesass/vscode-css-languageservice\");\nconst sass_1 = require(\"../facts/sass\");\nconst language_feature_1 = require(\"../language-feature\");\nconst language_services_types_1 = require(\"../language-services-types\");\nconst sass_2 = require(\"../utils/sass\");\nconst sassdoc_1 = require(\"../utils/sassdoc\");\nclass DoSignatureHelp extends language_feature_1.LanguageFeature {\n    async doSignatureHelp(document, position) {\n        const stylesheet = this.ls.parseStylesheet(document);\n        let node = (0, vscode_css_languageservice_1.getNodeAtOffset)(stylesheet, document.offsetAt(position));\n        if (!node) {\n            return null;\n        }\n        if (node.type !== language_services_types_1.NodeType.Function &&\n            node.type !== language_services_types_1.NodeType.MixinReference) {\n            const parent = node.findAParent(language_services_types_1.NodeType.Function, language_services_types_1.NodeType.MixinReference);\n            if (!parent) {\n                return null;\n            }\n            node = parent;\n        }\n        const result = {\n            activeSignature: 0,\n            activeParameter: 0,\n            signatures: [],\n        };\n        const identifier = node.getIdentifier().getText();\n        const parameters = node.getArguments().getChildren();\n        if (parameters.length) {\n            result.activeParameter = parameters.length - 1;\n            // Figure out how to se if we have a , after the last parameter. If so, add one to result.activeParameter.\n            const lastParamEndOffset = parameters[parameters.length - 1].end;\n            const lastParamEndPosition = document.positionAt(lastParamEndOffset);\n            const characterAfterLastParam = document.getText(vscode_css_languageservice_1.Range.create(lastParamEndPosition, {\n                line: lastParamEndPosition.line,\n                character: lastParamEndPosition.character + 1,\n            }));\n            if (characterAfterLastParam === \",\") {\n                result.activeParameter = result.activeParameter + 1;\n            }\n        }\n        const definition = await this.ls.findDefinition(document, document.positionAt(node.offset + identifier.length));\n        if (definition) {\n            const symbol = await this.findDefinitionSymbol(definition, identifier);\n            if (!symbol)\n                return result;\n            const allParameters = getParametersFromDetail(symbol.detail);\n            // activeParameter is 0 index\n            if (allParameters.length === 0 ||\n                allParameters.length > result.activeParameter) {\n                const signatureInfo = language_services_types_1.SignatureInformation.create(`${identifier}${symbol.detail || \"()\"}`);\n                const sassdoc = (0, sassdoc_1.applySassDoc)(symbol);\n                signatureInfo.documentation = {\n                    kind: language_services_types_1.MarkupKind.Markdown,\n                    value: sassdoc,\n                };\n                if (symbol.detail) {\n                    signatureInfo.parameters = [];\n                    const parameters = getParametersFromDetail(symbol.detail);\n                    for (const { name } of parameters) {\n                        let documentation;\n                        if (symbol.sassdoc) {\n                            const dollarless = (0, sass_2.asDollarlessVariable)(name);\n                            const paramDoc = symbol.sassdoc.parameter?.find((pdoc) => pdoc.name === dollarless);\n                            if (paramDoc) {\n                                documentation = paramDoc.description;\n                            }\n                        }\n                        signatureInfo.parameters.push({\n                            label: name.trim(),\n                            documentation,\n                        });\n                    }\n                }\n                result.signatures.push(signatureInfo);\n            }\n        }\n        else if (result.signatures.length === 0) {\n            // if no suggestion, look for built-in\n            for (const { reference, exports } of Object.values(sass_1.sassBuiltInModules)) {\n                for (const [name, { signature, description }] of Object.entries(exports)) {\n                    if (name === identifier) {\n                        // Make sure we don't accidentaly match with CSS functions by checking\n                        // for hints of a module name before the entry. Essentially look for \".\".\n                        // We could look for the module names, but that may be aliased away.\n                        // Do an includes-check in case signature har more than one parameter.\n                        const isNamespaced = node.parent?.type === language_services_types_1.NodeType.Module;\n                        if (!isNamespaced) {\n                            continue;\n                        }\n                        const signatureInfo = language_services_types_1.SignatureInformation.create(`${name}${signature}`);\n                        signatureInfo.documentation = {\n                            kind: language_services_types_1.MarkupKind.Markdown,\n                            value: `${description}\\n\\n[Sass reference](${reference}#${name})`,\n                        };\n                        if (signature) {\n                            const params = signature\n                                .replace(/:.+?(?=[,)])/g, \"\") // Remove default values in a non-greedy way\n                                .replace(/[().]/g, \"\") // Remove parentheses and ... list indicator\n                                .split(\",\");\n                            signatureInfo.parameters = params.map((p) => ({\n                                label: p.trim(),\n                            }));\n                        }\n                        result.signatures.push(signatureInfo);\n                        break;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nexports.DoSignatureHelp = DoSignatureHelp;\nfunction getParametersFromDetail(detail) {\n    const result = [];\n    if (!detail) {\n        return result;\n    }\n    const parameters = detail.replace(/[()]/g, \"\").split(\",\");\n    for (const param of parameters) {\n        let name = param;\n        let defaultValue = undefined;\n        const defaultValueStart = param.indexOf(\":\");\n        if (defaultValueStart !== -1) {\n            name = param.substring(0, defaultValueStart);\n            defaultValue = param.substring(defaultValueStart + 1);\n        }\n        const parameter = {\n            name: name.trim(),\n            defaultValue: defaultValue?.trim(),\n        };\n        result.push(parameter);\n    }\n    return result;\n}\n//# sourceMappingURL=do-signature-help.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applySassDoc = applySassDoc;\nfunction applySassDoc(symbol) {\n    if (!symbol.sassdoc) {\n        return \"\";\n    }\n    let description = \"\";\n    const doc = symbol.sassdoc;\n    if (doc.description) {\n        description += doc.description.trimStart();\n    }\n    // Make it visible early on if something is marked as deprecated\n    if (doc.deprecated) {\n        description += `\\n\\n@deprecated ${doc.deprecated}`;\n    }\n    if (doc.name && doc.name !== symbol.name) {\n        description += `\\n\\n@name ${doc.name}`;\n    }\n    // Function and mixin parameters, listed one per line like JSDoc\n    if (doc.parameter) {\n        for (const parameter of doc.parameter) {\n            description += \"\\n\\n@param\";\n            if (parameter.type) {\n                description += ` ${parameter.type}`;\n            }\n            description += `\\`${parameter.name}\\``;\n            if (parameter.default) {\n                description += ` [${parameter.default}]`;\n            }\n            if (parameter.description) {\n                description += ` - ${parameter.description}`;\n            }\n        }\n    }\n    // Type is for standalone variable annotation\n    // Type and Parameters is likely mutually exclusive\n    if (doc.type) {\n        description += `\\n\\n@type ${doc.type}`;\n    }\n    // Documents the properties of a map\n    if (doc.property) {\n        for (const prop of doc.property) {\n            description += \"\\n\\n@prop\";\n            if (prop.type) {\n                description += ` {${prop.type}}`;\n            }\n            description += `\\`${prop.path}\\``;\n            if (prop.default) {\n                description += ` [${prop.default}]`;\n            }\n            if (prop.description) {\n                description += ` - ${prop.description}`;\n            }\n        }\n    }\n    // For mixins that take @content\n    if (doc.content) {\n        description += `\\n\\n@content ${doc.content}`;\n    }\n    // Describes mixin output\n    if (doc.output) {\n        description += `\\n\\n@output ${doc.output}`;\n    }\n    // Describes function return values with a type and optional description\n    if (doc.return) {\n        description += `\\n\\n@return ${doc.return.type}${doc.return.description ? ` - ${doc.return.description}` : \"\"}`;\n    }\n    if (doc.throws) {\n        for (const thrown of doc.throws) {\n            description += `\\n\\n@throw ${thrown}`;\n        }\n    }\n    if (doc.require && doc.require.length > 0) {\n        for (const requirement of doc.require) {\n            description += \"\\n\\n@require\";\n            if (requirement.type) {\n                description += ` {${requirement.type}}`;\n            }\n            description += `\\`${requirement.name}\\``;\n            if (requirement.description) {\n                description += ` - ${requirement.description}`;\n            }\n            if (requirement.url) {\n                description += ` ${requirement.url}`;\n            }\n        }\n    }\n    if (doc.alias) {\n        const aliases = typeof doc.alias === \"string\" ? [doc.alias] : doc.alias;\n        for (const alias of aliases) {\n            description += `\\n\\n@alias \\`${alias}\\``;\n        }\n    }\n    // Hint to related variables, functions, or mixins\n    if (doc.see) {\n        for (const see of doc.see) {\n            description += `\\n\\n@see \\`${see.name}\\``;\n        }\n    }\n    if (doc.since) {\n        for (const since of doc.since) {\n            description += `\\n\\n@since ${since.version}`;\n            if (since.description) {\n                description += ` - ${since.description}`;\n            }\n        }\n    }\n    // Show credit to authors\n    if (doc.author) {\n        for (const author of doc.author) {\n            description += `\\n\\n@author ${author}`;\n        }\n    }\n    if (doc.link) {\n        for (const link of doc.link) {\n            description += link.caption\n                ? `\\n\\n[${link.caption}](${link.url})`\n                : `\\n\\n${link.url}`;\n        }\n    }\n    if (doc.example) {\n        for (const example of doc.example) {\n            description += \"\\n\\n@example\";\n            if (example.description) {\n                description += ` ${example.description}`;\n            }\n            description += [\n                \"\\n\",\n                `\\`\\`\\`${example.type || \"scss\"}`,\n                example.code,\n                \"```\",\n            ].join(\"\\n\");\n        }\n    }\n    if (doc.access === \"private\") {\n        description += `\\n\\n@access private`;\n    }\n    const groups = doc.group?.filter((g) => g !== \"undefined\");\n    if (groups && groups.length > 0) {\n        description += `\\n\\n@group ${groups.join(\", \")}`;\n    }\n    if (doc.todo) {\n        description += `\\n\\n@todo ${doc.todo}`;\n    }\n    return description;\n}\n//# sourceMappingURL=sassdoc.js.map","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\"use strict\";\nimport { MarkupKind, } from \"../cssLanguageTypes\";\nexport const browserNames = {\n    E: \"Edge\",\n    FF: \"Firefox\",\n    S: \"Safari\",\n    C: \"Chrome\",\n    IE: \"IE\",\n    O: \"Opera\",\n};\nfunction getEntryStatus(status) {\n    switch (status) {\n        case \"experimental\":\n            return \" Property is experimental. Be cautious when using it.\\n\\n\";\n        case \"nonstandard\":\n            return \" Property is nonstandard. Avoid using it.\\n\\n\";\n        case \"obsolete\":\n            return \" Property is obsolete. Avoid using it.\\n\\n\";\n        default:\n            return \"\";\n    }\n}\nexport function getEntryDescription(entry, doesSupportMarkdown, settings) {\n    let result;\n    if (doesSupportMarkdown) {\n        result = {\n            kind: \"markdown\",\n            value: getEntryMarkdownDescription(entry, settings),\n        };\n    }\n    else {\n        result = {\n            kind: \"plaintext\",\n            value: getEntryStringDescription(entry, settings),\n        };\n    }\n    if (result.value === \"\") {\n        return undefined;\n    }\n    return result;\n}\nexport function textToMarkedString(text) {\n    text = text.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, \"\\\\$&\"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\n    return text.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nfunction getEntryStringDescription(entry, settings) {\n    if (!entry.description || entry.description === \"\") {\n        return \"\";\n    }\n    if (typeof entry.description !== \"string\") {\n        return entry.description.value;\n    }\n    let result = \"\";\n    if (settings?.documentation !== false) {\n        if (entry.status) {\n            result += getEntryStatus(entry.status);\n        }\n        result += entry.description;\n        const browserLabel = getBrowserLabel(entry.browsers);\n        if (browserLabel) {\n            result += \"\\n(\" + browserLabel + \")\";\n        }\n        if (\"syntax\" in entry) {\n            result += `\\n\\nSyntax: ${entry.syntax}`;\n        }\n    }\n    if (entry.references && entry.references.length > 0 && settings?.references !== false) {\n        if (result.length > 0) {\n            result += \"\\n\\n\";\n        }\n        result += entry.references\n            .map((r) => {\n            return `${r.name}: ${r.url}`;\n        })\n            .join(\" | \");\n    }\n    return result;\n}\nfunction getEntryMarkdownDescription(entry, settings) {\n    if (!entry.description || entry.description === \"\") {\n        return \"\";\n    }\n    let result = \"\";\n    if (settings?.documentation !== false) {\n        if (entry.status) {\n            result += getEntryStatus(entry.status);\n        }\n        if (typeof entry.description === \"string\") {\n            result += textToMarkedString(entry.description);\n        }\n        else {\n            result +=\n                entry.description.kind === MarkupKind.Markdown\n                    ? entry.description.value\n                    : textToMarkedString(entry.description.value);\n        }\n        const browserLabel = getBrowserLabel(entry.browsers);\n        if (browserLabel) {\n            result += \"\\n\\n(\" + textToMarkedString(browserLabel) + \")\";\n        }\n        if (\"syntax\" in entry && entry.syntax) {\n            result += `\\n\\nSyntax: ${textToMarkedString(entry.syntax)}`;\n        }\n    }\n    if (entry.references && entry.references.length > 0 && settings?.references !== false) {\n        if (result.length > 0) {\n            result += \"\\n\\n\";\n        }\n        result += entry.references\n            .map((r) => {\n            return `[${r.name}](${r.url})`;\n        })\n            .join(\" | \");\n    }\n    return result;\n}\n/**\n * Input is like `[\"E12\",\"FF49\",\"C47\",\"IE\",\"O\"]`\n * Output is like `Edge 12, Firefox 49, Chrome 47, IE, Opera`\n */\nexport function getBrowserLabel(browsers = []) {\n    if (browsers.length === 0) {\n        return null;\n    }\n    return browsers\n        .map((b) => {\n        let result = \"\";\n        const matches = b.match(/([A-Z]+)(\\d+)?/);\n        const name = matches[1];\n        const version = matches[2];\n        if (name in browserNames) {\n            result += browserNames[name];\n        }\n        if (version) {\n            result += \" \" + version;\n        }\n        return result;\n    })\n        .join(\", \");\n}\n//# sourceMappingURL=entry.js.map","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\"use strict\";\nimport * as nodes from \"../parser/cssNodes\";\nimport { Scanner } from \"../parser/cssScanner\";\nimport * as l10n from \"@vscode/l10n\";\nimport { Parser } from \"../parser/cssParser\";\nexport class Element {\n    constructor() {\n        this.parent = null;\n        this.children = null;\n        this.attributes = null;\n    }\n    findAttribute(name) {\n        if (this.attributes) {\n            for (const attribute of this.attributes) {\n                if (attribute.name === name) {\n                    return attribute.value;\n                }\n            }\n        }\n        return null;\n    }\n    addChild(child) {\n        if (child instanceof Element) {\n            child.parent = this;\n        }\n        if (!this.children) {\n            this.children = [];\n        }\n        this.children.push(child);\n    }\n    append(text) {\n        if (this.attributes) {\n            const last = this.attributes[this.attributes.length - 1];\n            last.value = last.value + text;\n        }\n    }\n    prepend(text) {\n        if (this.attributes) {\n            const first = this.attributes[0];\n            first.value = text + first.value;\n        }\n    }\n    findRoot() {\n        let curr = this;\n        while (curr.parent && !(curr.parent instanceof RootElement)) {\n            curr = curr.parent;\n        }\n        return curr;\n    }\n    removeChild(child) {\n        if (this.children) {\n            const index = this.children.indexOf(child);\n            if (index !== -1) {\n                this.children.splice(index, 1);\n                return true;\n            }\n        }\n        return false;\n    }\n    addAttr(name, value) {\n        if (!this.attributes) {\n            this.attributes = [];\n        }\n        for (const attribute of this.attributes) {\n            if (attribute.name === name) {\n                attribute.value += \" \" + value;\n                return;\n            }\n        }\n        this.attributes.push({ name, value });\n    }\n    clone(cloneChildren = true) {\n        const elem = new Element();\n        if (this.attributes) {\n            elem.attributes = [];\n            for (const attribute of this.attributes) {\n                elem.addAttr(attribute.name, attribute.value);\n            }\n        }\n        if (cloneChildren && this.children) {\n            elem.children = [];\n            for (let index = 0; index < this.children.length; index++) {\n                elem.addChild(this.children[index].clone());\n            }\n        }\n        return elem;\n    }\n    cloneWithParent() {\n        const clone = this.clone(false);\n        if (this.parent && !(this.parent instanceof RootElement)) {\n            const parentClone = this.parent.cloneWithParent();\n            parentClone.addChild(clone);\n        }\n        return clone;\n    }\n}\nexport class RootElement extends Element {\n}\nexport class LabelElement extends Element {\n    constructor(label) {\n        super();\n        this.addAttr(\"name\", label);\n    }\n}\nclass MarkedStringPrinter {\n    constructor(quote) {\n        this.quote = quote;\n        this.result = [];\n        // empty\n    }\n    print(element, flagOpts) {\n        this.result = [];\n        if (element instanceof RootElement) {\n            if (element.children) {\n                this.doPrint(element.children, 0);\n            }\n        }\n        else {\n            this.doPrint([element], 0);\n        }\n        let value;\n        if (flagOpts) {\n            value = `${flagOpts.text}\\n  ` + this.result.join(\"\\n\");\n        }\n        else {\n            value = this.result.join(\"\\n\");\n        }\n        return [{ language: \"html\", value }];\n    }\n    doPrint(elements, indent) {\n        for (const element of elements) {\n            this.doPrintElement(element, indent);\n            if (element.children) {\n                this.doPrint(element.children, indent + 1);\n            }\n        }\n    }\n    writeLine(level, content) {\n        const indent = new Array(level + 1).join(\"  \");\n        this.result.push(indent + content);\n    }\n    doPrintElement(element, indent) {\n        const name = element.findAttribute(\"name\");\n        // special case: a simple label\n        if (element instanceof LabelElement || name === \"\\u2026\") {\n            this.writeLine(indent, name);\n            return;\n        }\n        // the real deal\n        const content = [\"<\"];\n        // element name\n        if (name) {\n            content.push(name);\n        }\n        else {\n            content.push(\"element\");\n        }\n        // attributes\n        if (element.attributes) {\n            for (const attr of element.attributes) {\n                if (attr.name !== \"name\") {\n                    content.push(\" \");\n                    content.push(attr.name);\n                    const value = attr.value;\n                    if (value) {\n                        content.push(\"=\");\n                        content.push(quotes.ensure(value, this.quote));\n                    }\n                }\n            }\n        }\n        content.push(\">\");\n        this.writeLine(indent, content.join(\"\"));\n    }\n}\nvar quotes;\n(function (quotes) {\n    function ensure(value, which) {\n        return which + remove(value) + which;\n    }\n    quotes.ensure = ensure;\n    function remove(value) {\n        const match = value.match(/^['\"](.*)[\"']$/);\n        if (match) {\n            return match[1];\n        }\n        return value;\n    }\n    quotes.remove = remove;\n})(quotes || (quotes = {}));\nclass Specificity {\n    constructor() {\n        /** Count of identifiers (e.g., `#app`) */\n        this.id = 0;\n        /** Count of attributes (`[type=\"number\"]`), classes (`.container-fluid`), and pseudo-classes (`:hover`) */\n        this.attr = 0;\n        /** Count of tag names (`div`), and pseudo-elements (`::before`) */\n        this.tag = 0;\n    }\n}\nexport function toElement(node, parentElement) {\n    let result = new Element();\n    for (const child of node.getChildren()) {\n        switch (child.type) {\n            case nodes.NodeType.SelectorCombinator:\n                if (parentElement) {\n                    const segments = child.getText().split(\"&\");\n                    if (segments.length === 1) {\n                        // should not happen\n                        result.addAttr(\"name\", segments[0]);\n                        break;\n                    }\n                    result = parentElement.cloneWithParent();\n                    if (segments[0]) {\n                        const root = result.findRoot();\n                        root.prepend(segments[0]);\n                    }\n                    for (let i = 1; i < segments.length; i++) {\n                        if (i > 1) {\n                            const clone = parentElement.cloneWithParent();\n                            result.addChild(clone.findRoot());\n                            result = clone;\n                        }\n                        result.append(segments[i]);\n                    }\n                }\n                break;\n            case nodes.NodeType.SelectorPlaceholder:\n                if (child.matches(\"@at-root\")) {\n                    return result;\n                }\n            // fall through\n            case nodes.NodeType.ElementNameSelector:\n                const text = child.getText();\n                result.addAttr(\"name\", text === \"*\" ? \"element\" : unescape(text));\n                break;\n            case nodes.NodeType.ClassSelector:\n                result.addAttr(\"class\", unescape(child.getText().substring(1)));\n                break;\n            case nodes.NodeType.IdentifierSelector:\n                result.addAttr(\"id\", unescape(child.getText().substring(1)));\n                break;\n            case nodes.NodeType.MixinDeclaration:\n                result.addAttr(\"class\", child.getName());\n                break;\n            case nodes.NodeType.PseudoSelector:\n                result.addAttr(unescape(child.getText()), \"\");\n                break;\n            case nodes.NodeType.AttributeSelector:\n                const selector = child;\n                const identifier = selector.getIdentifier();\n                if (identifier) {\n                    const expression = selector.getValue();\n                    const operator = selector.getOperator();\n                    let value;\n                    if (expression && operator) {\n                        switch (unescape(operator.getText())) {\n                            case \"|=\":\n                                // excatly or followed by -words\n                                value = `${quotes.remove(unescape(expression.getText()))}-\\u2026`;\n                                break;\n                            case \"^=\":\n                                // prefix\n                                value = `${quotes.remove(unescape(expression.getText()))}\\u2026`;\n                                break;\n                            case \"$=\":\n                                // suffix\n                                value = `\\u2026${quotes.remove(unescape(expression.getText()))}`;\n                                break;\n                            case \"~=\":\n                                // one of a list of words\n                                value = ` \\u2026 ${quotes.remove(unescape(expression.getText()))} \\u2026 `;\n                                break;\n                            case \"*=\":\n                                // substring\n                                value = `\\u2026${quotes.remove(unescape(expression.getText()))}\\u2026`;\n                                break;\n                            default:\n                                value = quotes.remove(unescape(expression.getText()));\n                                break;\n                        }\n                    }\n                    result.addAttr(unescape(identifier.getText()), value);\n                }\n                break;\n        }\n    }\n    return result;\n}\nfunction unescape(content) {\n    const scanner = new Scanner();\n    scanner.setSource(content);\n    const token = scanner.scanUnquotedString();\n    if (token) {\n        return token.text;\n    }\n    return content;\n}\nexport class SelectorPrinting {\n    constructor(cssDataManager) {\n        this.cssDataManager = cssDataManager;\n    }\n    selectorToMarkedString(node, flagOpts) {\n        const root = selectorToElement(node);\n        if (root) {\n            const markedStrings = new MarkedStringPrinter('\"').print(root, flagOpts);\n            markedStrings.push(this.selectorToSpecificityMarkedString(node));\n            return markedStrings;\n        }\n        else {\n            return [];\n        }\n    }\n    simpleSelectorToMarkedString(node) {\n        const element = toElement(node);\n        const markedStrings = new MarkedStringPrinter('\"').print(element);\n        markedStrings.push(this.selectorToSpecificityMarkedString(node));\n        return markedStrings;\n    }\n    isPseudoElementIdentifier(text) {\n        const match = text.match(/^::?([\\w-]+)/);\n        if (!match) {\n            return false;\n        }\n        return !!this.cssDataManager.getPseudoElement(\"::\" + match[1]);\n    }\n    selectorToSpecificityMarkedString(node) {\n        const calculateMostSpecificListItem = (childElements) => {\n            const specificity = new Specificity();\n            let mostSpecificListItem = new Specificity();\n            for (const containerElement of childElements) {\n                for (const childElement of containerElement.getChildren()) {\n                    const itemSpecificity = calculateScore(childElement);\n                    if (itemSpecificity.id > mostSpecificListItem.id) {\n                        mostSpecificListItem = itemSpecificity;\n                        continue;\n                    }\n                    else if (itemSpecificity.id < mostSpecificListItem.id) {\n                        continue;\n                    }\n                    if (itemSpecificity.attr > mostSpecificListItem.attr) {\n                        mostSpecificListItem = itemSpecificity;\n                        continue;\n                    }\n                    else if (itemSpecificity.attr < mostSpecificListItem.attr) {\n                        continue;\n                    }\n                    if (itemSpecificity.tag > mostSpecificListItem.tag) {\n                        mostSpecificListItem = itemSpecificity;\n                        continue;\n                    }\n                }\n            }\n            specificity.id += mostSpecificListItem.id;\n            specificity.attr += mostSpecificListItem.attr;\n            specificity.tag += mostSpecificListItem.tag;\n            return specificity;\n        };\n        //https://www.w3.org/TR/selectors-3/#specificity\n        const calculateScore = (node) => {\n            const specificity = new Specificity();\n            elementLoop: for (const element of node.getChildren()) {\n                switch (element.type) {\n                    case nodes.NodeType.IdentifierSelector:\n                        specificity.id++;\n                        break;\n                    case nodes.NodeType.ClassSelector:\n                    case nodes.NodeType.AttributeSelector:\n                        specificity.attr++;\n                        break;\n                    case nodes.NodeType.ElementNameSelector:\n                        //ignore universal selector\n                        if (element.matches(\"*\")) {\n                            break;\n                        }\n                        specificity.tag++;\n                        break;\n                    case nodes.NodeType.PseudoSelector:\n                        const text = element.getText();\n                        const childElements = element.getChildren();\n                        if (this.isPseudoElementIdentifier(text)) {\n                            if (text.match(/^::slotted/i) && childElements.length > 0) {\n                                // The specificity of ::slotted() is that of a pseudo-element, plus the specificity of its argument.\n                                // ::slotted() does not allow a selector list as its argument, but this isn't the right place to give feedback on validity.\n                                // Reporting the most specific child will be correct for correct CSS and will be forgiving in case of mistakes.\n                                specificity.tag++;\n                                let mostSpecificListItem = calculateMostSpecificListItem(childElements);\n                                specificity.id += mostSpecificListItem.id;\n                                specificity.attr += mostSpecificListItem.attr;\n                                specificity.tag += mostSpecificListItem.tag;\n                                continue elementLoop;\n                            }\n                            specificity.tag++; // pseudo element\n                            continue elementLoop;\n                        }\n                        // where and child selectors have zero specificity\n                        if (text.match(/^:where/i)) {\n                            continue elementLoop;\n                        }\n                        // the most specific child selector\n                        if (text.match(/^:(?:not|has|is)/i) && childElements.length > 0) {\n                            let mostSpecificListItem = calculateMostSpecificListItem(childElements);\n                            specificity.id += mostSpecificListItem.id;\n                            specificity.attr += mostSpecificListItem.attr;\n                            specificity.tag += mostSpecificListItem.tag;\n                            continue elementLoop;\n                        }\n                        if (text.match(/^:(?:host|host-context)/i) && childElements.length > 0) {\n                            // The specificity of :host() is that of a pseudo-class, plus the specificity of its argument.\n                            // The specificity of :host-context() is that of a pseudo-class, plus the specificity of its argument.\n                            specificity.attr++;\n                            let mostSpecificListItem = calculateMostSpecificListItem(childElements);\n                            specificity.id += mostSpecificListItem.id;\n                            specificity.attr += mostSpecificListItem.attr;\n                            specificity.tag += mostSpecificListItem.tag;\n                            continue elementLoop;\n                        }\n                        if (text.match(/^:(?:nth-child|nth-last-child)/i) && childElements.length > 0) {\n                            /* The specificity of the :nth-child(An+B [of S]?) pseudo-class is the specificity of a single pseudo-class plus, if S is specified, the specificity of the most specific complex selector in S */\n                            // https://www.w3.org/TR/selectors-4/#the-nth-child-pseudo\n                            specificity.attr++;\n                            // 23 = Binary Expression.\n                            if (childElements.length === 3 && childElements[1].type === 23) {\n                                let mostSpecificListItem = calculateMostSpecificListItem(childElements[2].getChildren());\n                                specificity.id += mostSpecificListItem.id;\n                                specificity.attr += mostSpecificListItem.attr;\n                                specificity.tag += mostSpecificListItem.tag;\n                                continue elementLoop;\n                            }\n                            // Edge case: 'n' without integer prefix A, with B integer non-existent, is not regarded as a binary expression token.\n                            const parser = new Parser();\n                            const pseudoSelectorText = childElements[1].getText();\n                            parser.scanner.setSource(pseudoSelectorText);\n                            const firstToken = parser.scanner.scan();\n                            const secondToken = parser.scanner.scan();\n                            if (firstToken.text === \"n\" || (firstToken.text === \"-n\" && secondToken.text === \"of\")) {\n                                const complexSelectorListNodes = [];\n                                const complexSelectorText = pseudoSelectorText.slice(secondToken.offset + 2);\n                                const complexSelectorArray = complexSelectorText.split(\",\");\n                                for (const selector of complexSelectorArray) {\n                                    const node = parser.internalParse(selector, parser._parseSelector);\n                                    if (node) {\n                                        complexSelectorListNodes.push(node);\n                                    }\n                                }\n                                let mostSpecificListItem = calculateMostSpecificListItem(complexSelectorListNodes);\n                                specificity.id += mostSpecificListItem.id;\n                                specificity.attr += mostSpecificListItem.attr;\n                                specificity.tag += mostSpecificListItem.tag;\n                                continue elementLoop;\n                            }\n                            continue elementLoop;\n                        }\n                        specificity.attr++; //pseudo class\n                        continue elementLoop;\n                }\n                if (element.getChildren().length > 0) {\n                    const itemSpecificity = calculateScore(element);\n                    specificity.id += itemSpecificity.id;\n                    specificity.attr += itemSpecificity.attr;\n                    specificity.tag += itemSpecificity.tag;\n                }\n            }\n            return specificity;\n        };\n        const specificity = calculateScore(node);\n        return `[${l10n.t(\"Selector Specificity\")}](https://developer.mozilla.org/docs/Web/CSS/Specificity): (${specificity.id}, ${specificity.attr}, ${specificity.tag})`;\n    }\n}\nclass SelectorElementBuilder {\n    constructor(element) {\n        this.prev = null;\n        this.element = element;\n    }\n    processSelector(selector) {\n        let parentElement = null;\n        if (!(this.element instanceof RootElement)) {\n            if (selector.getChildren().some((c) => c.hasChildren() && c.getChild(0).type === nodes.NodeType.SelectorCombinator)) {\n                const curr = this.element.findRoot();\n                if (curr.parent instanceof RootElement) {\n                    parentElement = this.element;\n                    this.element = curr.parent;\n                    this.element.removeChild(curr);\n                    this.prev = null;\n                }\n            }\n        }\n        for (const selectorChild of selector.getChildren()) {\n            if (selectorChild instanceof nodes.SimpleSelector) {\n                if (this.prev instanceof nodes.SimpleSelector) {\n                    const labelElement = new LabelElement(\"\\u2026\");\n                    this.element.addChild(labelElement);\n                    this.element = labelElement;\n                }\n                else if (this.prev && (this.prev.matches(\"+\") || this.prev.matches(\"~\")) && this.element.parent) {\n                    this.element = this.element.parent;\n                }\n                if (this.prev && this.prev.matches(\"~\")) {\n                    this.element.addChild(new LabelElement(\"\\u22EE\"));\n                }\n                const thisElement = toElement(selectorChild, parentElement);\n                const root = thisElement.findRoot();\n                this.element.addChild(root);\n                this.element = thisElement;\n            }\n            if (selectorChild instanceof nodes.SimpleSelector ||\n                selectorChild.type === nodes.NodeType.SelectorCombinatorParent ||\n                selectorChild.type === nodes.NodeType.SelectorCombinatorShadowPiercingDescendant ||\n                selectorChild.type === nodes.NodeType.SelectorCombinatorSibling ||\n                selectorChild.type === nodes.NodeType.SelectorCombinatorAllSiblings) {\n                this.prev = selectorChild;\n            }\n        }\n    }\n}\nfunction isNewSelectorContext(node) {\n    switch (node.type) {\n        case nodes.NodeType.MixinDeclaration:\n        case nodes.NodeType.Stylesheet:\n            return true;\n    }\n    return false;\n}\nexport function selectorToElement(node) {\n    if (node.matches(\"@at-root\")) {\n        return null;\n    }\n    const root = new RootElement();\n    const parentRuleSets = [];\n    const ruleSet = node.getParent();\n    if (ruleSet instanceof nodes.RuleSet) {\n        let parent = ruleSet.getParent(); // parent of the selector's ruleset\n        while (parent && !isNewSelectorContext(parent)) {\n            if (parent instanceof nodes.RuleSet) {\n                if (parent.getSelectors().matches(\"@at-root\")) {\n                    break;\n                }\n                parentRuleSets.push(parent);\n            }\n            parent = parent.getParent();\n        }\n    }\n    const builder = new SelectorElementBuilder(root);\n    for (let i = parentRuleSets.length - 1; i >= 0; i--) {\n        const selector = parentRuleSets[i].getSelectors().getChild(0);\n        if (selector) {\n            builder.processSelector(selector);\n        }\n    }\n    builder.processSelector(node);\n    return root;\n}\n//# sourceMappingURL=selectorPrinting.js.map"],"names":[],"mappings":";AAmvBA;AAAA;AA9MA;AAkPA;AAAA;AAIA;AAAA;AAnIA;AAmEA;AAAA;AAIA;AAAA;AAoCA;AAAA;AA5DA;AAAA;AAhBA;AAAA;ACjmBA;ACqDA;ACiRA;AAAA;;;AAwLA;AAAA;AAEA;AAAA;AAsDA;AAAA;AAIA;AAAA;AAEA;AAAA;AAgCA;AAAA;AAwDA;AAAA;AAIA;AAAA;AAEA;AAAA;AAkFA;AAAA;AA2NA;AAMA;AAEA;AAGA;AC/7BA;AA8FA;AA0BA;AAAA;AAGA;AAAA;AAgBA;AAAA;AAGA;AAAA;AAgBA;AAAA;AAEA;AAAA;AAmBA;AAAA;AAGA;AAAA;AC/LA;AAAA;AClFA;AAAA;AAGA;AAAA;AAqBA;AAAA;AAoBA;AAAA;AAIA;AAAA;AAIA;AAAA;AAIA;AAAA;AAqBA;AAAA;AAMA;AAAA;AAKA;AAAA;AASA;AAAA;AAMA;AAAA;AACA;AAAA;AAkBA;AAAA;AAIA;AAAA;AAGA;AAAA;ACtCA;AAAA;AAtCA;AAAA;AC2DA"}